var data = {lines:[
{"lineNum":"    1","line":"# Grisu3 is ported from the C++ \"double-conversions\" library."},
{"lineNum":"    2","line":"# The following is their license:"},
{"lineNum":"    3","line":"#   Copyright 2012 the V8 project authors. All rights reserved."},
{"lineNum":"    4","line":"#   Redistribution and use in source and binary forms, with or without"},
{"lineNum":"    5","line":"#   modification, are permitted provided that the following conditions are"},
{"lineNum":"    6","line":"#   met:"},
{"lineNum":"    7","line":"#"},
{"lineNum":"    8","line":"#       * Redistributions of source code must retain the above copyright"},
{"lineNum":"    9","line":"#         notice, this list of conditions and the following disclaimer."},
{"lineNum":"   10","line":"#       * Redistributions in binary form must reproduce the above"},
{"lineNum":"   11","line":"#         copyright notice, this list of conditions and the following"},
{"lineNum":"   12","line":"#         disclaimer in the documentation and/or other materials provided"},
{"lineNum":"   13","line":"#         with the distribution."},
{"lineNum":"   14","line":"#       * Neither the name of Google Inc. nor the names of its"},
{"lineNum":"   15","line":"#         contributors may be used to endorse or promote products derived"},
{"lineNum":"   16","line":"#         from this software without specific prior written permission."},
{"lineNum":"   17","line":"#"},
{"lineNum":"   18","line":"#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS"},
{"lineNum":"   19","line":"#   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT"},
{"lineNum":"   20","line":"#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR"},
{"lineNum":"   21","line":"#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT"},
{"lineNum":"   22","line":"#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,"},
{"lineNum":"   23","line":"#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT"},
{"lineNum":"   24","line":"#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   25","line":"#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY"},
{"lineNum":"   26","line":"#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT"},
{"lineNum":"   27","line":"#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE"},
{"lineNum":"   28","line":"#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"require \"./diy_fp\""},
{"lineNum":"   31","line":"require \"./ieee\""},
{"lineNum":"   32","line":"require \"./cached_powers\""},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"module Float::Printer::Grisu3"},
{"lineNum":"   35","line":"  extend self"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"  # Adjusts the last digit of the generated number, and screens out generated"},
{"lineNum":"   38","line":"  # solutions that may be inaccurate. A solution may be inaccurate if it is"},
{"lineNum":"   39","line":"  # outside the safe interval, or if we cannot prove that it is closer to the"},
{"lineNum":"   40","line":"  # input than a neighboring representation of the same length."},
{"lineNum":"   41","line":"  #"},
{"lineNum":"   42","line":"  # Input: * buffer pointer containing the digits of too_high / 10^kappa"},
{"lineNum":"   43","line":"  #        * the buffer\'s length"},
{"lineNum":"   44","line":"  #        * distance_too_high_w == (too_high - w).frac * unit"},
{"lineNum":"   45","line":"  #        * unsafe_interval == (too_high - too_low).frac * unit"},
{"lineNum":"   46","line":"  #        * rest = (too_high - buffer * 10^kappa).frac * unit"},
{"lineNum":"   47","line":"  #        * ten_kappa = 10^kappa * unit"},
{"lineNum":"   48","line":"  #        * unit = the common multiplier"},
{"lineNum":"   49","line":"  # Output: returns true if the buffer is guaranteed to contain the closest"},
{"lineNum":"   50","line":"  #    representable number to the input."},
{"lineNum":"   51","line":"  #  Modifies the generated digits in the buffer to approach (round towards) w."},
{"lineNum":"   52","line":"  def round_weed(buffer_p, length, distance_too_high_w, unsafe_interval, rest, ten_kappa, unit)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   53","line":"    buffer = buffer_p.to_slice(128)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   54","line":"    small_distance = distance_too_high_w - unit","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   55","line":"    big_distance = distance_too_high_w + unit"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"    # Let w_low  = too_high - big_distance, and"},
{"lineNum":"   58","line":"    #     w_high = too_high - small_distance."},
{"lineNum":"   59","line":"    # Note: w_low < w < w_high"},
{"lineNum":"   60","line":"    #"},
{"lineNum":"   61","line":"    # The real w (* unit) must lie somewhere inside the interval"},
{"lineNum":"   62","line":"    # ]w_low; w_high[ (often written as \"(w_low; w_high)\")"},
{"lineNum":"   63","line":"    #"},
{"lineNum":"   64","line":"    # Basically the buffer currently contains a number in the unsafe interval"},
{"lineNum":"   65","line":"    # ]too_low; too_high[ with too_low < w < too_high"},
{"lineNum":"   66","line":"    #"},
{"lineNum":"   67","line":"    #  too_high - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"},
{"lineNum":"   68","line":"    #                     ^v 1 unit            ^      ^                 ^      ^"},
{"lineNum":"   69","line":"    #  boundary_high ---------------------     .      .                 .      ."},
{"lineNum":"   70","line":"    #                     ^v 1 unit            .      .                 .      ."},
{"lineNum":"   71","line":"    #   - - - - - - - - - - - - - - - - - - -  +  - - + - - - - - -     .      ."},
{"lineNum":"   72","line":"    #                                          .      .         ^       .      ."},
{"lineNum":"   73","line":"    #                                          .  big_distance  .       .      ."},
{"lineNum":"   74","line":"    #                                          .      .         .       .    rest"},
{"lineNum":"   75","line":"    #                              small_distance     .         .       .      ."},
{"lineNum":"   76","line":"    #                                          v      .         .       .      ."},
{"lineNum":"   77","line":"    #  w_high - - - - - - - - - - - - - - - - - -     .         .       .      ."},
{"lineNum":"   78","line":"    #                     ^v 1 unit                   .         .       .      ."},
{"lineNum":"   79","line":"    #  w ----------------------------------------     .         .       .      ."},
{"lineNum":"   80","line":"    #                     ^v 1 unit                   v         .       .      ."},
{"lineNum":"   81","line":"    #  w_low  - - - - - - - - - - - - - - - - - - - - -         .       .      ."},
{"lineNum":"   82","line":"    #                                                           .       .      v"},
{"lineNum":"   83","line":"    #  buffer --------------------------------------------------+-------+--------"},
{"lineNum":"   84","line":"    #                                                           .       ."},
{"lineNum":"   85","line":"    #                                                  safe_interval    ."},
{"lineNum":"   86","line":"    #                                                           v       ."},
{"lineNum":"   87","line":"    #   - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     ."},
{"lineNum":"   88","line":"    #                     ^v 1 unit                                     ."},
{"lineNum":"   89","line":"    #  boundary_low -------------------------                     unsafe_interval"},
{"lineNum":"   90","line":"    #                     ^v 1 unit                                     v"},
{"lineNum":"   91","line":"    #  too_low  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"},
{"lineNum":"   92","line":"    #"},
{"lineNum":"   93","line":"    #"},
{"lineNum":"   94","line":"    # Note that the value of buffer could lie anywhere inside the range too_low"},
{"lineNum":"   95","line":"    # to too_high."},
{"lineNum":"   96","line":"    #"},
{"lineNum":"   97","line":"    # boundary_low, boundary_high and w are approximations of the real boundaries"},
{"lineNum":"   98","line":"    # and v (the input number). They are guaranteed to be precise up to one unit."},
{"lineNum":"   99","line":"    # In fact the error is guaranteed to be strictly less than one unit."},
{"lineNum":"  100","line":"    #"},
{"lineNum":"  101","line":"    # Anything that lies outside the unsafe interval is guaranteed not to round"},
{"lineNum":"  102","line":"    # to v when read again."},
{"lineNum":"  103","line":"    # Anything that lies inside the safe interval is guaranteed to round to v"},
{"lineNum":"  104","line":"    # when read again."},
{"lineNum":"  105","line":"    # If the number inside the buffer lies inside the unsafe interval but not"},
{"lineNum":"  106","line":"    # inside the safe interval then we simply do not know and bail out (returning"},
{"lineNum":"  107","line":"    # false)."},
{"lineNum":"  108","line":"    #"},
{"lineNum":"  109","line":"    # Similarly we have to take into account the imprecision of \'w\' when finding"},
{"lineNum":"  110","line":"    # the closest representation of \'w\'. If we have two potential"},
{"lineNum":"  111","line":"    # representations, and one is closer to both w_low and w_high, then we know"},
{"lineNum":"  112","line":"    # it is closer to the actual value v."},
{"lineNum":"  113","line":"    #"},
{"lineNum":"  114","line":"    # By generating the digits of too_high we got the largest (closest to"},
{"lineNum":"  115","line":"    # too_high) buffer that is still in the unsafe interval. In the case where"},
{"lineNum":"  116","line":"    # w_high < buffer < too_high we try to decrement the buffer."},
{"lineNum":"  117","line":"    # This way the buffer approaches (rounds towards) w."},
{"lineNum":"  118","line":"    # There are 3 conditions that stop the decrementation process:"},
{"lineNum":"  119","line":"    #   1) the buffer is already below w_high"},
{"lineNum":"  120","line":"    #   2) decrementing the buffer would make it leave the unsafe interval"},
{"lineNum":"  121","line":"    #   3) decrementing the buffer would yield a number below w_high and farther"},
{"lineNum":"  122","line":"    #      away than the current number. In other words:"},
{"lineNum":"  123","line":"    #              (buffer{-1} < w_high) && w_high - buffer{-1} > buffer - w_high"},
{"lineNum":"  124","line":"    # Instead of using the buffer directly we use its distance to too_high."},
{"lineNum":"  125","line":"    # Conceptually rest ~= too_high - buffer"},
{"lineNum":"  126","line":"    # We need to do the following tests in this order to avoid over- and"},
{"lineNum":"  127","line":"    # underflows."},
{"lineNum":"  128","line":"    _invariant rest <= unsafe_interval"},
{"lineNum":"  129","line":"    while ("},
{"lineNum":"  130","line":"            rest < small_distance &&    # Negated condition 1"},
{"lineNum":"  131","line":" unsafe_interval - rest >= ten_kappa && # Negated condition 2"},
{"lineNum":"  132","line":" (rest + ten_kappa < small_distance ||  # buffer{-1} > w_high","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  133","line":" small_distance - rest >= rest + ten_kappa - small_distance)"},
{"lineNum":"  134","line":"          )"},
{"lineNum":"  135","line":"      buffer[length - 1] -= 1"},
{"lineNum":"  136","line":"      rest += ten_kappa"},
{"lineNum":"  137","line":"    end"},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"    # We have approached w+ as much as possible. We now test if approaching w-"},
{"lineNum":"  140","line":"    # would require changing the buffer. If yes, then we have two possible"},
{"lineNum":"  141","line":"    # representations close to w, but we cannot decide which one is closer."},
{"lineNum":"  142","line":"    if ("},
{"lineNum":"  143","line":"         rest < big_distance &&"},
{"lineNum":"  144","line":"         unsafe_interval - rest >= ten_kappa &&"},
{"lineNum":"  145","line":"         (rest + ten_kappa < big_distance || big_distance - rest > rest + ten_kappa - big_distance)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  146","line":"       )"},
{"lineNum":"  147","line":"      return false"},
{"lineNum":"  148","line":"    end"},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"    # Weeding test."},
{"lineNum":"  151","line":"    #   The safe interval is [too_low + 2 ulp; too_high - 2 ulp]"},
{"lineNum":"  152","line":"    #   Since too_low = too_high - unsafe_interval this is equivalent to"},
{"lineNum":"  153","line":"    #      [too_high - unsafe_interval + 4 ulp; too_high - 2 ulp]"},
{"lineNum":"  154","line":"    #   Conceptually we have: rest ~= too_high - buffer"},
{"lineNum":"  155","line":"    return (2 * unit <= rest) && (rest <= unsafe_interval - 4 * unit)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  156","line":"  end"},
{"lineNum":"  157","line":""},
{"lineNum":"  158","line":"  # Generates the digits of input number w."},
{"lineNum":"  159","line":"  # w is a floating-point number (DiyFp), consisting of a significand and an"},
{"lineNum":"  160","line":"  # exponent. Its exponent is bounded by kMinimalTargetExponent and"},
{"lineNum":"  161","line":"  # kMaximalTargetExponent."},
{"lineNum":"  162","line":"  #       Hence -60 <= w.e() <= -32."},
{"lineNum":"  163","line":"  #"},
{"lineNum":"  164","line":"  # Returns false if it fails, in which case the generated digits in the buffer"},
{"lineNum":"  165","line":"  # should not be used."},
{"lineNum":"  166","line":"  # Preconditions:"},
{"lineNum":"  167","line":"  #  * low, w and high are correct up to 1 ulp (unit in the last place). That"},
{"lineNum":"  168","line":"  #    is, their error must be less than a unit of their last digits."},
{"lineNum":"  169","line":"  #  * low.e() == w.e() == high.e()"},
{"lineNum":"  170","line":"  #  * low < w < high, and taking into account their error: low~ <= high~"},
{"lineNum":"  171","line":"  #  * kMinimalTargetExponent <= w.e() <= kMaximalTargetExponent"},
{"lineNum":"  172","line":"  # Postconditions: returns false if procedure fails."},
{"lineNum":"  173","line":"  #   otherwise:"},
{"lineNum":"  174","line":"  #     * buffer is not null-terminated, but len contains the number of digits."},
{"lineNum":"  175","line":"  #     * buffer contains the shortest possible decimal digit-sequence"},
{"lineNum":"  176","line":"  #       such that LOW < buffer * 10^kappa < HIGH, where LOW and HIGH are the"},
{"lineNum":"  177","line":"  #       correct values of low and high (without their error)."},
{"lineNum":"  178","line":"  #     * if more than one decimal representation gives the minimal number of"},
{"lineNum":"  179","line":"  #       decimal digits then the one closest to W (where W is the correct value"},
{"lineNum":"  180","line":"  #       of w) is chosen."},
{"lineNum":"  181","line":"  # Remark: this procedure takes into account the imprecision of its input"},
{"lineNum":"  182","line":"  #   numbers. If the precision is not enough to guarantee all the postconditions"},
{"lineNum":"  183","line":"  #   then false is returned. This usually happens rarely (~0.5%)."},
{"lineNum":"  184","line":"  #"},
{"lineNum":"  185","line":"  # Say, for the sake of example, that"},
{"lineNum":"  186","line":"  #   w.e() == -48, and w.f() == 0x1234567890abcdef"},
{"lineNum":"  187","line":"  # w\'s value can be computed by w.f() * 2^w.e()"},
{"lineNum":"  188","line":"  # We can obtain w\'s integral digits by simply shifting w.f() by -w.e()."},
{"lineNum":"  189","line":"  #  -> w\'s integral part is 0x1234"},
{"lineNum":"  190","line":"  #  w\'s fractional part is therefore 0x567890abcdef."},
{"lineNum":"  191","line":"  # Printing w\'s integral part is easy (simply print 0x1234 in decimal)."},
{"lineNum":"  192","line":"  # In order to print its fraction we repeatedly multiply the fraction by 10 and"},
{"lineNum":"  193","line":"  # get each digit. Example the first digit after the point would be computed by"},
{"lineNum":"  194","line":"  #   (0x567890abcdef * 10) >> 48. -> 3"},
{"lineNum":"  195","line":"  # The whole thing becomes slightly more complicated because we want to stop"},
{"lineNum":"  196","line":"  # once we have enough digits. That is, once the digits inside the buffer"},
{"lineNum":"  197","line":"  # represent \'w\' we can stop. Everything inside the interval low - high"},
{"lineNum":"  198","line":"  # represents w. However we have to pay attention to low, high and w\'s"},
{"lineNum":"  199","line":"  # imprecision."},
{"lineNum":"  200","line":"  def digit_gen(low : DiyFP, w : DiyFP, high : DiyFP, buffer_p) : {Bool, Int32, Int32}"},
{"lineNum":"  201","line":"    buffer = buffer_p.to_slice(128)"},
{"lineNum":"  202","line":"    _invariant low.exp == w.exp && w.exp == high.exp"},
{"lineNum":"  203","line":"    _invariant low.frac + 1 <= high.frac - 1"},
{"lineNum":"  204","line":"    _invariant CachedPowers::MIN_TARGET_EXP <= w.exp && w.exp <= CachedPowers::MAX_TARGET_EXP"},
{"lineNum":"  205","line":"    # low, w and high are imprecise, but by less than one ulp (unit in the last"},
{"lineNum":"  206","line":"    # place)."},
{"lineNum":"  207","line":"    # If we remove (resp. add) 1 ulp from low (resp. high) we are certain that"},
{"lineNum":"  208","line":"    # the new numbers are outside of the interval we want the final"},
{"lineNum":"  209","line":"    # representation to lie in."},
{"lineNum":"  210","line":"    # Inversely adding (resp. removing) 1 ulp from low (resp. high) would yield"},
{"lineNum":"  211","line":"    # numbers that are certain to lie in the interval. We will use this fact"},
{"lineNum":"  212","line":"    # later on."},
{"lineNum":"  213","line":"    # We will now start by generating the digits within the uncertain"},
{"lineNum":"  214","line":"    # interval. Later we will weed out representations that lie outside the safe"},
{"lineNum":"  215","line":"    # interval and thus _might_ lie outside the correct interval."},
{"lineNum":"  216","line":"    unit = 1_u64","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  217","line":"    too_low = DiyFP.new(low.frac - unit, low.exp)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  218","line":"    too_high = DiyFP.new(high.frac + unit, low.exp)"},
{"lineNum":"  219","line":"    # too_low and too_high are guaranteed to lie outside the interval we want the"},
{"lineNum":"  220","line":"    # generated number in."},
{"lineNum":"  221","line":"    unsafe_interval = too_high - too_low"},
{"lineNum":"  222","line":"    # We now cut the input number into two parts: the integral digits and the"},
{"lineNum":"  223","line":"    # fractionals. We will not write any decimal separator though, but adapt"},
{"lineNum":"  224","line":"    # kappa instead."},
{"lineNum":"  225","line":"    # Reminder: we are currently computing the digits (stored inside the buffer)"},
{"lineNum":"  226","line":"    # such that:   too_low < buffer * 10^kappa < too_high"},
{"lineNum":"  227","line":"    # We use too_high for the digit_generation and stop as soon as possible."},
{"lineNum":"  228","line":"    # If we stop early we effectively round down."},
{"lineNum":"  229","line":"    one = DiyFP.new(1_u64 << -w.exp, w.exp)"},
{"lineNum":"  230","line":"    # Division by one is a shift."},
{"lineNum":"  231","line":"    integrals = (too_high.frac >> -one.exp).to_u32","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  232","line":"    # Modulo by one is an and."},
{"lineNum":"  233","line":"    fractionals = too_high.frac & (one.frac - 1)"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"    # note: In the C++ version this was: SignificandSize - (-one.e())"},
{"lineNum":"  236","line":"    divisor, kappa = CachedPowers.largest_pow10(integrals, DiyFP::SIGNIFICAND_SIZE + one.exp)"},
{"lineNum":"  237","line":"    length = 0"},
{"lineNum":"  238","line":"    # pp kappa"},
{"lineNum":"  239","line":"    # pp divisor"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"    # Loop invariant: buffer = too_high / 10^kappa  (integer division)"},
{"lineNum":"  242","line":"    # The invariant holds for the first iteration: kappa has been initialized"},
{"lineNum":"  243","line":"    # with the divisor exponent + 1. And the divisor is the biggest power of ten"},
{"lineNum":"  244","line":"    # that is smaller than integrals."},
{"lineNum":"  245","line":"    while kappa > 0","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  246","line":"      digit = integrals / divisor","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  247","line":"      # pp [digit, kappa]"},
{"lineNum":"  248","line":"      _invariant digit <= 9"},
{"lineNum":"  249","line":"      buffer[length] = 48_u8 + digit","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  250","line":"      length += 1"},
{"lineNum":"  251","line":"      integrals %= divisor","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  252","line":"      kappa -= 1"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"      # Note that kappa now equals the exponent of the divisor and that the"},
{"lineNum":"  255","line":"      # invariant thus holds again."},
{"lineNum":"  256","line":"      rest = (integrals.to_u64 << -one.exp) + fractionals","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"      # Invariant: too_high = buffer * 10^kappa + DiyFp(rest, one.e())"},
{"lineNum":"  259","line":"      # Reminder: unsafe_interval.e() == one.e()"},
{"lineNum":"  260","line":"      if rest < unsafe_interval.frac","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  261","line":"        # Rounding down (by not emitting the remaining digits) yields a number"},
{"lineNum":"  262","line":"        # that lies within the unsafe interval."},
{"lineNum":"  263","line":"        weeded = round_weed(buffer_p, length, (too_high - w).frac, unsafe_interval.frac, rest, divisor.to_u64 << -one.exp, unit)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  264","line":"        return weeded, kappa, length"},
{"lineNum":"  265","line":"      end"},
{"lineNum":"  266","line":""},
{"lineNum":"  267","line":"      divisor /= 10"},
{"lineNum":"  268","line":"    end"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"    # The integrals have been generated. We are at the point of the decimal"},
{"lineNum":"  271","line":"    # separator. In the following loop we simply multiply the remaining digits by"},
{"lineNum":"  272","line":"    # 10 and divide by one. We just need to pay attention to multiply associated"},
{"lineNum":"  273","line":"    # data (like the interval or \'unit\'), too."},
{"lineNum":"  274","line":"    # Note that the multiplication by 10 does not overflow, because w.e >= -60"},
{"lineNum":"  275","line":"    # and thus one.e >= -60."},
{"lineNum":"  276","line":"    _invariant one.exp >= -60"},
{"lineNum":"  277","line":"    _invariant fractionals < one.frac"},
{"lineNum":"  278","line":"    _invariant 0xFFFFFFFFFFFFFFFF / 10 >= one.frac"},
{"lineNum":"  279","line":"    loop do"},
{"lineNum":"  280","line":"      fractionals *= 10","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  281","line":"      unit *= 10","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  282","line":"      unsafe_interval = DiyFP.new(unsafe_interval.frac * 10, unsafe_interval.exp)"},
{"lineNum":"  283","line":"      digit = (fractionals >> -one.exp).to_i","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  284","line":"      _invariant digit <= 9"},
{"lineNum":"  285","line":"      buffer[length] = 48_u8 + digit","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  286","line":"      length += 1","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  287","line":"      fractionals &= one.frac - 1","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  288","line":"      kappa -= 1"},
{"lineNum":"  289","line":"      if fractionals < unsafe_interval.frac","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  290","line":"        weeded = round_weed(buffer_p, length, (too_high - w).frac * unit, unsafe_interval.frac, fractionals, one.frac, unit)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  291","line":"        return weeded, kappa, length"},
{"lineNum":"  292","line":"      end"},
{"lineNum":"  293","line":"    end"},
{"lineNum":"  294","line":"  end"},
{"lineNum":"  295","line":""},
{"lineNum":"  296","line":"  # Provides a decimal representation of *v*."},
{"lineNum":"  297","line":"  #"},
{"lineNum":"  298","line":"  # Returns a `Tuple` of `{status, decimal_exponent, length}`"},
{"lineNum":"  299","line":"  # *status* will be true if it succeeds, otherwise the result cannot be"},
{"lineNum":"  300","line":"  # trusted."},
{"lineNum":"  301","line":"  # There will be *length* digits inside the buffer (not null-terminated)."},
{"lineNum":"  302","line":"  # If the function returns satatus as true true then"},
{"lineNum":"  303","line":"  #        v == (buffer * 10^decimal_exponent).to_f"},
{"lineNum":"  304","line":"  # The digits in the buffer are the shortest representation possible: no"},
{"lineNum":"  305","line":"  # 0.09999999999999999 instead of 0.1. The shorter representation will even be"},
{"lineNum":"  306","line":"  # chosen even if the longer one would be closer to *v*."},
{"lineNum":"  307","line":"  # The last digit will be closest to the actual *v*. That is, even if several"},
{"lineNum":"  308","line":"  # digits might correctly yield *v* when read again, the closest will be"},
{"lineNum":"  309","line":"  # computed."},
{"lineNum":"  310","line":"  def grisu3(v : Float64 | Float32, buffer_p) : {Bool, Int32, Int32}"},
{"lineNum":"  311","line":"    buffer = buffer_p.to_slice(128)"},
{"lineNum":"  312","line":""},
{"lineNum":"  313","line":"    w = DiyFP.from_f_normalized(v)"},
{"lineNum":"  314","line":""},
{"lineNum":"  315","line":"    # boundary_minus and boundary_plus are the boundaries between v and its"},
{"lineNum":"  316","line":"    # closest floating-point neighbors. Any number strictly between"},
{"lineNum":"  317","line":"    # boundary_minus and boundary_plus will round to v when convert to a float."},
{"lineNum":"  318","line":"    # Grisu3 will never output representations that lie exactly on a boundary."},
{"lineNum":"  319","line":"    boundaries = IEEE.normalized_boundaries(v)"},
{"lineNum":"  320","line":"    _invariant boundaries[:plus].exp == w.exp"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"    ten_mk, mk = CachedPowers.get_cached_power_for_binary_exponent(w.exp)"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"    # Note that ten_mk is only an approximation of 10^-k. A DiyFp only contains a"},
{"lineNum":"  325","line":"    # 64 bit significand and ten_mk is thus only precise up to 64 bits."},
{"lineNum":"  326","line":"    #"},
{"lineNum":"  327","line":"    # The DiyFp::Times procedure rounds its result, and ten_mk is approximated"},
{"lineNum":"  328","line":"    # too. The variable scaled_w (as well as scaled_boundary_minus/plus) are now"},
{"lineNum":"  329","line":"    # off by a small amount."},
{"lineNum":"  330","line":"    # In fact: scaled_w - w*10^k < 1ulp (unit in the last place) of scaled_w."},
{"lineNum":"  331","line":"    # In other words: let f = scaled_w.f() and e = scaled_w.e(), then"},
{"lineNum":"  332","line":"    #           (f-1) * 2^e < w*10^k < (f+1) * 2^e"},
{"lineNum":"  333","line":"    scaled_w = w * ten_mk"},
{"lineNum":"  334","line":"    _invariant scaled_w.exp == boundaries[:plus].exp + ten_mk.exp + DiyFP::SIGNIFICAND_SIZE"},
{"lineNum":"  335","line":""},
{"lineNum":"  336","line":"    # In theory it would be possible to avoid some recomputations by computing"},
{"lineNum":"  337","line":"    # the difference between w and boundary_minus/plus (a power of 2) and to"},
{"lineNum":"  338","line":"    # compute scaled_boundary_minus/plus by subtracting/adding from"},
{"lineNum":"  339","line":"    # scaled_w. However the code becomes much less readable and the speed"},
{"lineNum":"  340","line":"    # enhancements are not terriffic."},
{"lineNum":"  341","line":"    scaled_boundary_minus = boundaries[:minus] * ten_mk"},
{"lineNum":"  342","line":"    scaled_boundary_plus = boundaries[:plus] * ten_mk"},
{"lineNum":"  343","line":""},
{"lineNum":"  344","line":"    # #digit_gen will generate the digits of scaled_w. Therefore we have"},
{"lineNum":"  345","line":"    # v == (scaled_w * 10^-mk).to_f"},
{"lineNum":"  346","line":"    # Set decimal_exponent == -mk and pass it to DigitGen. If scaled_w is not an"},
{"lineNum":"  347","line":"    # integer than it will be updated. For instance if scaled_w == 1.23 then"},
{"lineNum":"  348","line":"    # the buffer will be filled with \"123\" und the decimal_exponent will be"},
{"lineNum":"  349","line":"    # decreased by 2."},
{"lineNum":"  350","line":"    result, kappa, length = digit_gen(scaled_boundary_minus, scaled_w, scaled_boundary_plus, buffer_p)"},
{"lineNum":"  351","line":""},
{"lineNum":"  352","line":"    decimal_exponent = -mk + kappa","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  353","line":"    return result, decimal_exponent, length"},
{"lineNum":"  354","line":"  end"},
{"lineNum":"  355","line":""},
{"lineNum":"  356","line":"  private macro _invariant(exp, file = __FILE__, line = __LINE__)"},
{"lineNum":"  357","line":"    {% if !flag?(:release) %}"},
{"lineNum":"  358","line":"      unless {{exp}}"},
{"lineNum":"  359","line":"        raise \"Assertion Failed #{{{file}}}:#{{{line}}}\""},
{"lineNum":"  360","line":"      end"},
{"lineNum":"  361","line":"    {% end %}"},
{"lineNum":"  362","line":"  end"},
{"lineNum":"  363","line":"end"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "roman_spec", "date" : "2018-03-12 14:24:04", "instrumented" : 26, "covered" : 0,};
var merged_data = [];
