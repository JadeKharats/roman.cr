var data = {lines:[
{"lineNum":"    1","line":"require \"c/sys/time\""},
{"lineNum":"    2","line":"require \"c/time\""},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"{% if flag?(:darwin) %}"},
{"lineNum":"    5","line":"  # Darwin supports clock_gettime starting from macOS Sierra, but we can\'t"},
{"lineNum":"    6","line":"  # use it because it would prevent running binaries built on macOS Sierra"},
{"lineNum":"    7","line":"  # to run on older macOS releases."},
{"lineNum":"    8","line":"  #"},
{"lineNum":"    9","line":"  # Furthermore, mach_absolute_time is reported to have a higher precision."},
{"lineNum":"   10","line":"  require \"c/mach/mach_time\""},
{"lineNum":"   11","line":"{% end %}"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"module Crystal::System::Time"},
{"lineNum":"   14","line":"  UnixEpochInSeconds = 62135596800_i64"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"  def self.compute_utc_offset(seconds : Int64) : Int32"},
{"lineNum":"   17","line":"    LibC.tzset"},
{"lineNum":"   18","line":"    offset = nil"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"    {% if LibC.methods.includes?(\"daylight\".id) %}"},
{"lineNum":"   21","line":"      if LibC.daylight == 0"},
{"lineNum":"   22","line":"        # current TZ doesn\'t have any DST, neither in past, present or future"},
{"lineNum":"   23","line":"        offset = -LibC.timezone.to_i"},
{"lineNum":"   24","line":"      end"},
{"lineNum":"   25","line":"    {% end %}"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"    unless offset"},
{"lineNum":"   28","line":"      seconds_from_epoch = LibC::TimeT.new(seconds - UnixEpochInSeconds)"},
{"lineNum":"   29","line":"      # current TZ may have DST, either in past, present or future"},
{"lineNum":"   30","line":"      ret = LibC.localtime_r(pointerof(seconds_from_epoch), out tm)"},
{"lineNum":"   31","line":"      raise Errno.new(\"localtime_r\") if ret.null?"},
{"lineNum":"   32","line":"      offset = tm.tm_gmtoff.to_i"},
{"lineNum":"   33","line":"    end"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"    offset"},
{"lineNum":"   36","line":"  end"},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"  def self.compute_utc_seconds_and_nanoseconds : {Int64, Int32}"},
{"lineNum":"   39","line":"    {% if LibC.methods.includes?(\"clock_gettime\".id) %}"},
{"lineNum":"   40","line":"      ret = LibC.clock_gettime(LibC::CLOCK_REALTIME, out timespec)"},
{"lineNum":"   41","line":"      raise Errno.new(\"clock_gettime\") unless ret == 0"},
{"lineNum":"   42","line":"      {timespec.tv_sec.to_i64 + UnixEpochInSeconds, timespec.tv_nsec.to_i}"},
{"lineNum":"   43","line":"    {% else %}"},
{"lineNum":"   44","line":"      ret = LibC.gettimeofday(out timeval, nil)"},
{"lineNum":"   45","line":"      raise Errno.new(\"gettimeofday\") unless ret == 0"},
{"lineNum":"   46","line":"      {timeval.tv_sec.to_i64 + UnixEpochInSeconds, timeval.tv_usec.to_i * 1_000}"},
{"lineNum":"   47","line":"    {% end %}"},
{"lineNum":"   48","line":"  end"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"  def self.monotonic"},
{"lineNum":"   51","line":"    {% if flag?(:darwin) %}","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"   52","line":"      info = mach_timebase_info"},
{"lineNum":"   53","line":"      total_nanoseconds = LibC.mach_absolute_time * info.numer / info.denom"},
{"lineNum":"   54","line":"      seconds = total_nanoseconds / 1_000_000_000"},
{"lineNum":"   55","line":"      nanoseconds = total_nanoseconds.remainder(1_000_000_000)"},
{"lineNum":"   56","line":"      {seconds.to_i64, nanoseconds.to_i32}"},
{"lineNum":"   57","line":"    {% else %}"},
{"lineNum":"   58","line":"      if LibC.clock_gettime(LibC::CLOCK_MONOTONIC, out tp) == 1"},
{"lineNum":"   59","line":"        raise Errno.new(\"clock_gettime(CLOCK_MONOTONIC)\")"},
{"lineNum":"   60","line":"      end"},
{"lineNum":"   61","line":"      {tp.tv_sec.to_i64, tp.tv_nsec.to_i32}"},
{"lineNum":"   62","line":"    {% end %}"},
{"lineNum":"   63","line":"  end"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"  {% if flag?(:darwin) %}"},
{"lineNum":"   66","line":"    @@mach_timebase_info : LibC::MachTimebaseInfo?"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"    private def self.mach_timebase_info"},
{"lineNum":"   69","line":"      @@mach_timebase_info ||= begin"},
{"lineNum":"   70","line":"        LibC.mach_timebase_info(out info)"},
{"lineNum":"   71","line":"        info"},
{"lineNum":"   72","line":"      end"},
{"lineNum":"   73","line":"    end"},
{"lineNum":"   74","line":"  {% end %}"},
{"lineNum":"   75","line":"end"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "roman_spec", "date" : "2018-03-12 14:57:27", "instrumented" : 1, "covered" : 0,};
var merged_data = [];
