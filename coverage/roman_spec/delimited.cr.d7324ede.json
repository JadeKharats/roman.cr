var data = {lines:[
{"lineNum":"    1","line":"# An `IO` that wraps another `IO`, and only reads up to the beginning of a"},
{"lineNum":"    2","line":"# specified delimiter."},
{"lineNum":"    3","line":"#"},
{"lineNum":"    4","line":"# This is useful for exposing part of an underlying stream to a client."},
{"lineNum":"    5","line":"#"},
{"lineNum":"    6","line":"# ```"},
{"lineNum":"    7","line":"# io = IO::Memory.new \"abc||123\""},
{"lineNum":"    8","line":"# delimited = IO::Delimited.new(io, read_delimiter: \"||\")"},
{"lineNum":"    9","line":"#"},
{"lineNum":"   10","line":"# delimited.gets_to_end # => \"abc\""},
{"lineNum":"   11","line":"# delimited.gets_to_end # => \"\""},
{"lineNum":"   12","line":"# io.gets_to_end        # => \"123\""},
{"lineNum":"   13","line":"# ```"},
{"lineNum":"   14","line":"class IO::Delimited < IO"},
{"lineNum":"   15","line":"  # If `#sync_close?` is `true`, closing this `IO` will close the underlying `IO`."},
{"lineNum":"   16","line":"  property? sync_close"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"  getter read_delimiter"},
{"lineNum":"   19","line":"  getter? closed : Bool"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"  @delimiter_buffer : Bytes"},
{"lineNum":"   22","line":"  @active_delimiter_buffer : Bytes"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"  # Creates a new `IO::Delimited` which wraps *io*, and can read until the"},
{"lineNum":"   25","line":"  # byte sequence *read_delimiter* (interpreted as UTF-8) is found. If"},
{"lineNum":"   26","line":"  # *sync_close* is set, calling `#close` calls `#close` on the underlying"},
{"lineNum":"   27","line":"  # `IO`."},
{"lineNum":"   28","line":"  def self.new(io : IO, read_delimiter : String, sync_close : Bool = false)"},
{"lineNum":"   29","line":"    new(io, read_delimiter.to_slice, sync_close)"},
{"lineNum":"   30","line":"  end"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"  # Creates a new `IO::Delimited` which wraps *io*, and can read until the"},
{"lineNum":"   33","line":"  # byte sequence *read_delimiter* is found. If *sync_close* is set, calling"},
{"lineNum":"   34","line":"  # `#close` calls `#close` on the underlying `IO`."},
{"lineNum":"   35","line":"  def initialize(@io : IO, @read_delimiter : Bytes, @sync_close : Bool = false)"},
{"lineNum":"   36","line":"    @closed = false"},
{"lineNum":"   37","line":"    @finished = false"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"    # The buffer where we do all our work."},
{"lineNum":"   40","line":"    @delimiter_buffer = Bytes.new(@read_delimiter.size)"},
{"lineNum":"   41","line":"    # Slice inside delimiter buffer where bytes waiting to be read are stored."},
{"lineNum":"   42","line":"    @active_delimiter_buffer = Bytes.empty"},
{"lineNum":"   43","line":"  end"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"  def read(slice : Bytes)"},
{"lineNum":"   46","line":"    check_open"},
{"lineNum":"   47","line":"    return 0 if @finished"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"    first_byte = @read_delimiter[0]"},
{"lineNum":"   50","line":"    read_bytes = 0"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"    while read_bytes < slice.size"},
{"lineNum":"   53","line":"      # Select the next byte as the head of the active delimiter buffer,"},
{"lineNum":"   54","line":"      # or the next byte from the io if the buffer is not in use."},
{"lineNum":"   55","line":"      if @active_delimiter_buffer.size > 0"},
{"lineNum":"   56","line":"        byte = @active_delimiter_buffer[0]"},
{"lineNum":"   57","line":"        @active_delimiter_buffer += 1"},
{"lineNum":"   58","line":"      else"},
{"lineNum":"   59","line":"        byte = @io.read_byte"},
{"lineNum":"   60","line":"      end"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"      break if byte.nil?"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"      # We know we don\'t need to check if the delimiter matches when the buffer"},
{"lineNum":"   65","line":"      # has been resized, because this signals we are coming to the end of the IO."},
{"lineNum":"   66","line":"      if byte == first_byte && @delimiter_buffer.size == @read_delimiter.size"},
{"lineNum":"   67","line":"        buffer = @delimiter_buffer"},
{"lineNum":"   68","line":"        buffer[0] = byte"},
{"lineNum":"   69","line":"        read_start = 1"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"        # If we have an active delimiter buffer copy it in after the current"},
{"lineNum":"   72","line":"        # character, and update where we should start our read operation."},
{"lineNum":"   73","line":"        if @active_delimiter_buffer.size > 0"},
{"lineNum":"   74","line":"          (buffer + 1).move_from(@active_delimiter_buffer)"},
{"lineNum":"   75","line":"          read_start += @active_delimiter_buffer.size"},
{"lineNum":"   76","line":"        end"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"        read_buffer = buffer + read_start"},
{"lineNum":"   79","line":"        bytes = 0"},
{"lineNum":"   80","line":"        while read_buffer.size > 0"},
{"lineNum":"   81","line":"          partial_bytes = @io.read(read_buffer)"},
{"lineNum":"   82","line":"          break if partial_bytes == 0"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"          read_buffer += partial_bytes"},
{"lineNum":"   85","line":"          bytes += partial_bytes"},
{"lineNum":"   86","line":"        end"},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":"        # If read didn\'t read as many bytes as we asked it to, resize the buffer"},
{"lineNum":"   89","line":"        # to remove garbage bytes."},
{"lineNum":"   90","line":"        if bytes != buffer.size - read_start"},
{"lineNum":"   91","line":"          buffer = buffer[0, read_start + bytes]"},
{"lineNum":"   92","line":"        end"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"        if buffer == @read_delimiter"},
{"lineNum":"   95","line":"          @finished = true"},
{"lineNum":"   96","line":"          return read_bytes"},
{"lineNum":"   97","line":"        end"},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"        @delimiter_buffer = buffer"},
{"lineNum":"  100","line":"        @active_delimiter_buffer = buffer + 1"},
{"lineNum":"  101","line":"      end"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"      slice[read_bytes] = byte"},
{"lineNum":"  104","line":"      read_bytes += 1"},
{"lineNum":"  105","line":"    end"},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"    read_bytes"},
{"lineNum":"  108","line":"  end"},
{"lineNum":"  109","line":""},
{"lineNum":"  110","line":"  def write(slice : Bytes)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  111","line":"    raise IO::Error.new \"Can\'t write to IO::Delimited\"","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  112","line":"  end"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"  def close","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  115","line":"    return if @closed","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  116","line":"    @closed = true","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"    @io.close if @sync_close","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  119","line":"  end"},
{"lineNum":"  120","line":"end"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "roman_spec", "date" : "2018-03-12 14:24:04", "instrumented" : 6, "covered" : 0,};
var merged_data = [];
