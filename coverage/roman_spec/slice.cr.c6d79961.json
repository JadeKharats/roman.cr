var data = {lines:[
{"lineNum":"    1","line":"require \"c/string\""},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"# A `Slice` is a `Pointer` with an associated size."},
{"lineNum":"    4","line":"#"},
{"lineNum":"    5","line":"# While a pointer is unsafe because no bound checks are performed when reading from and writing to it,"},
{"lineNum":"    6","line":"# reading from and writing to a slice involve bound checks."},
{"lineNum":"    7","line":"# In this way, a slice is a safe alternative to `Pointer`."},
{"lineNum":"    8","line":"#"},
{"lineNum":"    9","line":"# A Slice can be created as read-only: trying to write to it"},
{"lineNum":"   10","line":"# will raise. For example the slice of bytes returned by"},
{"lineNum":"   11","line":"# `String#to_slice` is read-only."},
{"lineNum":"   12","line":"struct Slice(T)"},
{"lineNum":"   13","line":"  include Indexable(T)"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"  # Create a new `Slice` with the given *args*. The type of the"},
{"lineNum":"   16","line":"  # slice will be the union of the type of the given *args*."},
{"lineNum":"   17","line":"  #"},
{"lineNum":"   18","line":"  # The slice is allocated on the heap."},
{"lineNum":"   19","line":"  #"},
{"lineNum":"   20","line":"  # ```"},
{"lineNum":"   21","line":"  # slice = Slice[1, \'a\']"},
{"lineNum":"   22","line":"  # slice[0]    # => 1"},
{"lineNum":"   23","line":"  # slice[1]    # => \'a\'"},
{"lineNum":"   24","line":"  # slice.class # => Slice(Char | Int32)"},
{"lineNum":"   25","line":"  # ```"},
{"lineNum":"   26","line":"  #"},
{"lineNum":"   27","line":"  # If `T` is a `Number` then this is equivalent to"},
{"lineNum":"   28","line":"  # `Number.slice` (numbers will be coerced to the type `T`)"},
{"lineNum":"   29","line":"  #"},
{"lineNum":"   30","line":"  # See also: `Number.slice`."},
{"lineNum":"   31","line":"  macro [](*args, read_only = false)"},
{"lineNum":"   32","line":"    # TODO: there should be a better way to check this, probably"},
{"lineNum":"   33","line":"    # asking if @type was instantiated or if T is defined"},
{"lineNum":"   34","line":"    {% if @type.name != \"Slice(T)\" && T < Number %}"},
{"lineNum":"   35","line":"      {{T}}.slice({{*args}}, read_only: {{read_only}})"},
{"lineNum":"   36","line":"    {% else %}"},
{"lineNum":"   37","line":"      %ptr = Pointer(typeof({{*args}})).malloc({{args.size}})"},
{"lineNum":"   38","line":"      {% for arg, i in args %}"},
{"lineNum":"   39","line":"        %ptr[{{i}}] = {{arg}}"},
{"lineNum":"   40","line":"      {% end %}"},
{"lineNum":"   41","line":"      Slice.new(%ptr, {{args.size}}, read_only: {{read_only}})"},
{"lineNum":"   42","line":"    {% end %}"},
{"lineNum":"   43","line":"  end"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"  # Returns the size of this slice."},
{"lineNum":"   46","line":"  #"},
{"lineNum":"   47","line":"  # ```"},
{"lineNum":"   48","line":"  # Slice(UInt8).new(3).size # => 3"},
{"lineNum":"   49","line":"  # ```"},
{"lineNum":"   50","line":"  getter size : Int32"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"  # Returns `true` if this slice cannot be written to."},
{"lineNum":"   53","line":"  getter? read_only : Bool"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"  # Creates a slice to the given *pointer*, bounded by the given *size*. This"},
{"lineNum":"   56","line":"  # method does not allocate heap memory."},
{"lineNum":"   57","line":"  #"},
{"lineNum":"   58","line":"  # ```"},
{"lineNum":"   59","line":"  # ptr = Pointer.malloc(9) { |i| (\'a\'.ord + i).to_u8 }"},
{"lineNum":"   60","line":"  #"},
{"lineNum":"   61","line":"  # slice = Slice.new(ptr, 3)"},
{"lineNum":"   62","line":"  # slice.size # => 3"},
{"lineNum":"   63","line":"  # slice      # => Bytes[97, 98, 99]"},
{"lineNum":"   64","line":"  #"},
{"lineNum":"   65","line":"  # String.new(slice) # => \"abc\""},
{"lineNum":"   66","line":"  # ```"},
{"lineNum":"   67","line":"  def initialize(@pointer : Pointer(T), size : Int, *, @read_only = false)"},
{"lineNum":"   68","line":"    @size = size.to_i32"},
{"lineNum":"   69","line":"  end"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"  # Allocates `size * sizeof(T)` bytes of heap memory initialized to zero"},
{"lineNum":"   72","line":"  # and returns a slice pointing to that memory."},
{"lineNum":"   73","line":"  #"},
{"lineNum":"   74","line":"  # The memory is allocated by the `GC`, so when there are"},
{"lineNum":"   75","line":"  # no pointers to this memory, it will be automatically freed."},
{"lineNum":"   76","line":"  #"},
{"lineNum":"   77","line":"  # Only works for primitive integers and floats (`UInt8`, `Int32`, `Float64`, etc.)"},
{"lineNum":"   78","line":"  #"},
{"lineNum":"   79","line":"  # ```"},
{"lineNum":"   80","line":"  # slice = Slice(UInt8).new(3)"},
{"lineNum":"   81","line":"  # slice # => Bytes[0, 0, 0]"},
{"lineNum":"   82","line":"  # ```"},
{"lineNum":"   83","line":"  def self.new(size : Int, *, read_only = false)"},
{"lineNum":"   84","line":"    {% unless T <= Int::Primitive || T <= Float::Primitive %}"},
{"lineNum":"   85","line":"      {% raise \"Can only use primitive integers and floats with Slice.new(size), not #{T}\" %}"},
{"lineNum":"   86","line":"    {% end %}"},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":"    pointer = Pointer(T).malloc(size)"},
{"lineNum":"   89","line":"    new(pointer, size, read_only: read_only)"},
{"lineNum":"   90","line":"  end"},
{"lineNum":"   91","line":""},
{"lineNum":"   92","line":"  # Allocates `size * sizeof(T)` bytes of heap memory initialized to the value"},
{"lineNum":"   93","line":"  # returned by the block (which is invoked once with each index in the range `0...size`)"},
{"lineNum":"   94","line":"  # and returns a slice pointing to that memory."},
{"lineNum":"   95","line":"  #"},
{"lineNum":"   96","line":"  # The memory is allocated by the `GC`, so when there are"},
{"lineNum":"   97","line":"  # no pointers to this memory, it will be automatically freed."},
{"lineNum":"   98","line":"  #"},
{"lineNum":"   99","line":"  # ```"},
{"lineNum":"  100","line":"  # slice = Slice.new(3) { |i| i + 10 }"},
{"lineNum":"  101","line":"  # slice # => Slice[10, 11, 12]"},
{"lineNum":"  102","line":"  # ```"},
{"lineNum":"  103","line":"  def self.new(size : Int, *, read_only = false)"},
{"lineNum":"  104","line":"    pointer = Pointer.malloc(size) { |i| yield i }"},
{"lineNum":"  105","line":"    new(pointer, size, read_only: read_only)"},
{"lineNum":"  106","line":"  end"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"  # Allocates `size * sizeof(T)` bytes of heap memory initialized to *value*"},
{"lineNum":"  109","line":"  # and returns a slice pointing to that memory."},
{"lineNum":"  110","line":"  #"},
{"lineNum":"  111","line":"  # The memory is allocated by the `GC`, so when there are"},
{"lineNum":"  112","line":"  # no pointers to this memory, it will be automatically freed."},
{"lineNum":"  113","line":"  #"},
{"lineNum":"  114","line":"  # ```"},
{"lineNum":"  115","line":"  # slice = Slice.new(3, 10)"},
{"lineNum":"  116","line":"  # slice # => Slice[10, 10, 10]"},
{"lineNum":"  117","line":"  # ```"},
{"lineNum":"  118","line":"  def self.new(size : Int, value : T, *, read_only = false)"},
{"lineNum":"  119","line":"    new(size, read_only: read_only) { value }"},
{"lineNum":"  120","line":"  end"},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"  # Returns a copy of this slice."},
{"lineNum":"  123","line":"  # This method allocates memory for the slice copy."},
{"lineNum":"  124","line":"  def clone"},
{"lineNum":"  125","line":"    copy = self.class.new(size)"},
{"lineNum":"  126","line":"    copy.copy_from(self)"},
{"lineNum":"  127","line":"    copy"},
{"lineNum":"  128","line":"  end"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"  # Creates an empty slice."},
{"lineNum":"  131","line":"  #"},
{"lineNum":"  132","line":"  # ```"},
{"lineNum":"  133","line":"  # slice = Slice(UInt8).empty"},
{"lineNum":"  134","line":"  # slice.size # => 0"},
{"lineNum":"  135","line":"  # ```"},
{"lineNum":"  136","line":"  def self.empty"},
{"lineNum":"  137","line":"    new(Pointer(T).null, 0)"},
{"lineNum":"  138","line":"  end"},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"  # Returns a new slice that is *offset* elements apart from this slice."},
{"lineNum":"  141","line":"  #"},
{"lineNum":"  142","line":"  # ```"},
{"lineNum":"  143","line":"  # slice = Slice.new(5) { |i| i + 10 }"},
{"lineNum":"  144","line":"  # slice # => Slice[10, 11, 12, 13, 14]"},
{"lineNum":"  145","line":"  #"},
{"lineNum":"  146","line":"  # slice2 = slice + 2"},
{"lineNum":"  147","line":"  # slice2 # => Slice[12, 13, 14]"},
{"lineNum":"  148","line":"  # ```"},
{"lineNum":"  149","line":"  def +(offset : Int)"},
{"lineNum":"  150","line":"    unless 0 <= offset <= size"},
{"lineNum":"  151","line":"      raise IndexError.new","class":"lineNoCov","hits":"0","possible_hits":"39",},
{"lineNum":"  152","line":"    end"},
{"lineNum":"  153","line":""},
{"lineNum":"  154","line":"    Slice.new(@pointer + offset, @size - offset, read_only: @read_only)","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  155","line":"  end"},
{"lineNum":"  156","line":""},
{"lineNum":"  157","line":"  # Sets the given value at the given *index*."},
{"lineNum":"  158","line":"  #"},
{"lineNum":"  159","line":"  # Negative indices can be used to start counting from the end of the slice."},
{"lineNum":"  160","line":"  # Raises `IndexError` if trying to set an element outside the slice\'s range."},
{"lineNum":"  161","line":"  #"},
{"lineNum":"  162","line":"  # ```"},
{"lineNum":"  163","line":"  # slice = Slice.new(5) { |i| i + 10 }"},
{"lineNum":"  164","line":"  # slice[0] = 20"},
{"lineNum":"  165","line":"  # slice[-1] = 30"},
{"lineNum":"  166","line":"  # slice # => Slice[20, 11, 12, 13, 30]"},
{"lineNum":"  167","line":"  #"},
{"lineNum":"  168","line":"  # slice[10] = 1 # raises IndexError"},
{"lineNum":"  169","line":"  # ```"},
{"lineNum":"  170","line":"  @[AlwaysInline]"},
{"lineNum":"  171","line":"  def []=(index : Int, value : T)"},
{"lineNum":"  172","line":"    check_writable"},
{"lineNum":"  173","line":""},
{"lineNum":"  174","line":"    index += size if index < 0","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  175","line":"    unless 0 <= index < size"},
{"lineNum":"  176","line":"      raise IndexError.new"},
{"lineNum":"  177","line":"    end"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"    @pointer[index] = value"},
{"lineNum":"  180","line":"  end"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"  # Returns a new slice that starts at *start* elements from this slice\'s start,"},
{"lineNum":"  183","line":"  # and of *count* size.","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  184","line":"  #"},
{"lineNum":"  185","line":"  # Raises `IndexError` if the new slice falls outside this slice."},
{"lineNum":"  186","line":"  #"},
{"lineNum":"  187","line":"  # ```"},
{"lineNum":"  188","line":"  # slice = Slice.new(5) { |i| i + 10 }"},
{"lineNum":"  189","line":"  # slice # => Slice[10, 11, 12, 13, 14]"},
{"lineNum":"  190","line":"  #"},
{"lineNum":"  191","line":"  # slice2 = slice[1, 3]"},
{"lineNum":"  192","line":"  # slice2 # => Slice[11, 12, 13]"},
{"lineNum":"  193","line":"  # ```"},
{"lineNum":"  194","line":"  def [](start, count)"},
{"lineNum":"  195","line":"    unless 0 <= start <= @size"},
{"lineNum":"  196","line":"      raise IndexError.new","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  197","line":"    end"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"    unless 0 <= count <= @size - start"},
{"lineNum":"  200","line":"      raise IndexError.new","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  201","line":"    end"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"    Slice.new(@pointer + start, count, read_only: @read_only)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  204","line":"  end"},
{"lineNum":"  205","line":""},
{"lineNum":"  206","line":"  @[AlwaysInline]"},
{"lineNum":"  207","line":"  def unsafe_at(index : Int)"},
{"lineNum":"  208","line":"    @pointer[index]"},
{"lineNum":"  209","line":"  end"},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"  # Reverses in-place all the elements of `self`."},
{"lineNum":"  212","line":"  def reverse!"},
{"lineNum":"  213","line":"    check_writable"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"    i = 0"},
{"lineNum":"  216","line":"    j = size - 1"},
{"lineNum":"  217","line":"    while i < j","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  218","line":"      @pointer.swap i, j"},
{"lineNum":"  219","line":"      i += 1"},
{"lineNum":"  220","line":"      j -= 1"},
{"lineNum":"  221","line":"    end"},
{"lineNum":"  222","line":"    self"},
{"lineNum":"  223","line":"  end"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"  def pointer(size)"},
{"lineNum":"  226","line":"    unless 0 <= size <= @size"},
{"lineNum":"  227","line":"      raise IndexError.new","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  228","line":"    end"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"    @pointer"},
{"lineNum":"  231","line":"  end"},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"  def shuffle!(random = Random::DEFAULT)"},
{"lineNum":"  234","line":"    check_writable"},
{"lineNum":"  235","line":"","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  236","line":"    @pointer.shuffle!(size, random)"},
{"lineNum":"  237","line":"  end"},
{"lineNum":"  238","line":""},
{"lineNum":"  239","line":"  # Invokes the given block for each element of `self`, replacing the element"},
{"lineNum":"  240","line":"  # with the value returned by the block. Returns `self`."},
{"lineNum":"  241","line":"  #"},
{"lineNum":"  242","line":"  # ```","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  243","line":"  # slice = Slice[1, 2, 3]"},
{"lineNum":"  244","line":"  # slice.map! { |x| x * x }"},
{"lineNum":"  245","line":"  # slice # => Slice[1, 4, 9]"},
{"lineNum":"  246","line":"  # ```"},
{"lineNum":"  247","line":"  def map!"},
{"lineNum":"  248","line":"    check_writable"},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"    @pointer.map!(size) { |e| yield e }"},
{"lineNum":"  251","line":"    self"},
{"lineNum":"  252","line":"  end","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"  # Returns a new slice where elements are mapped by the given block."},
{"lineNum":"  255","line":"  #"},
{"lineNum":"  256","line":"  # ```"},
{"lineNum":"  257","line":"  # slice = Slice[1, 2.5, \"a\"]"},
{"lineNum":"  258","line":"  # slice.map &.to_s # => Slice[\"1\", \"2.5\", \"a\"]"},
{"lineNum":"  259","line":"  # ```"},
{"lineNum":"  260","line":"  def map(*, read_only = false, &block : T -> U) forall U"},
{"lineNum":"  261","line":"    Slice.new(size, read_only: read_only) { |i| yield @pointer[i] }"},
{"lineNum":"  262","line":"  end"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"  # Like `map!`, but the block gets passed both the element and its index."},
{"lineNum":"  265","line":"  def map_with_index!(&block : (T, Int32) -> T)"},
{"lineNum":"  266","line":"    check_writable"},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"    @pointer.map_with_index!(size) { |e, i| yield e, i }"},
{"lineNum":"  269","line":"    self"},
{"lineNum":"  270","line":"  end"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"  # Like `map`, but the block gets passed both the element and its index."},
{"lineNum":"  273","line":"  def map_with_index(*, read_only = false, &block : (T, Int32) -> U) forall U"},
{"lineNum":"  274","line":"    Slice.new(size, read_only: read_only) { |i| yield @pointer[i], i }"},
{"lineNum":"  275","line":"  end"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"  def copy_from(source : Pointer(T), count)"},
{"lineNum":"  278","line":"    check_writable"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"    pointer(count).copy_from(source, count)"},
{"lineNum":"  281","line":"  end"},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"  def copy_to(target : Pointer(T), count)"},
{"lineNum":"  284","line":"    pointer(count).copy_to(target, count)"},
{"lineNum":"  285","line":"  end"},
{"lineNum":"  286","line":""},
{"lineNum":"  287","line":"  # Copies the contents of this slice into *target*."},
{"lineNum":"  288","line":"  #"},
{"lineNum":"  289","line":"  # Raises `IndexError` if the desination slice cannot fit the data being transferred"},
{"lineNum":"  290","line":"  # e.g. dest.size < self.size."},
{"lineNum":"  291","line":"  #"},
{"lineNum":"  292","line":"  # ```"},
{"lineNum":"  293","line":"  # src = Slice[\'a\', \'a\', \'a\']"},
{"lineNum":"  294","line":"  # dst = Slice[\'b\', \'b\', \'b\', \'b\', \'b\']"},
{"lineNum":"  295","line":"  # src.copy_to dst"},
{"lineNum":"  296","line":"  # dst             # => Slice[\'a\', \'a\', \'a\', \'b\', \'b\']"},
{"lineNum":"  297","line":"  # dst.copy_to src # raises IndexError"},
{"lineNum":"  298","line":"  # ```"},
{"lineNum":"  299","line":"  def copy_to(target : self)"},
{"lineNum":"  300","line":"    target.check_writable"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"    @pointer.copy_to(target.pointer(size), size)"},
{"lineNum":"  303","line":"  end"},
{"lineNum":"  304","line":""},
{"lineNum":"  305","line":"  # Copies the contents of *source* into this slice."},
{"lineNum":"  306","line":"  #"},
{"lineNum":"  307","line":"  # Raises `IndexError` if the desination slice cannot fit the data being transferred."},
{"lineNum":"  308","line":"  @[AlwaysInline]"},
{"lineNum":"  309","line":"  def copy_from(source : self)"},
{"lineNum":"  310","line":"    source.copy_to(self)"},
{"lineNum":"  311","line":"  end"},
{"lineNum":"  312","line":""},
{"lineNum":"  313","line":"  def move_from(source : Pointer(T), count)"},
{"lineNum":"  314","line":"    check_writable"},
{"lineNum":"  315","line":""},
{"lineNum":"  316","line":"    pointer(count).move_from(source, count)"},
{"lineNum":"  317","line":"  end"},
{"lineNum":"  318","line":""},
{"lineNum":"  319","line":"  def move_to(target : Pointer(T), count)"},
{"lineNum":"  320","line":"    pointer(count).move_to(target, count)"},
{"lineNum":"  321","line":"  end"},
{"lineNum":"  322","line":""},
{"lineNum":"  323","line":"  # Moves the contents of this slice into *target*. *target* and `self` may"},
{"lineNum":"  324","line":"  # overlap; the copy is always done in a non-destructive manner."},
{"lineNum":"  325","line":"  #"},
{"lineNum":"  326","line":"  # Raises `IndexError` if the desination slice cannot fit the data being transferred"},
{"lineNum":"  327","line":"  # e.g. `dest.size < self.size`."},
{"lineNum":"  328","line":"  #"},
{"lineNum":"  329","line":"  # ```"},
{"lineNum":"  330","line":"  # src = Slice[\'a\', \'a\', \'a\']"},
{"lineNum":"  331","line":"  # dst = Slice[\'b\', \'b\', \'b\', \'b\', \'b\']"},
{"lineNum":"  332","line":"  # src.move_to dst"},
{"lineNum":"  333","line":"  # dst             # => Slice[\'a\', \'a\', \'a\', \'b\', \'b\']"},
{"lineNum":"  334","line":"  # dst.move_to src # raises IndexError"},
{"lineNum":"  335","line":"  # ```"},
{"lineNum":"  336","line":"  #"},
{"lineNum":"  337","line":"  # See also: `Pointer#move_to`."},
{"lineNum":"  338","line":"  def move_to(target : self)"},
{"lineNum":"  339","line":"    target.check_writable"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"    @pointer.move_to(target.pointer(size), size)"},
{"lineNum":"  342","line":"  end"},
{"lineNum":"  343","line":""},
{"lineNum":"  344","line":"  # Moves the contents of *source* into this slice. *source* and `self` may"},
{"lineNum":"  345","line":"  # overlap; the copy is always done in a non-destructive manner."},
{"lineNum":"  346","line":"  #"},
{"lineNum":"  347","line":"  # Raises `IndexError` if the desination slice cannot fit the data being transferred."},
{"lineNum":"  348","line":"  @[AlwaysInline]"},
{"lineNum":"  349","line":"  def move_from(source : self)"},
{"lineNum":"  350","line":"    source.move_to(self)"},
{"lineNum":"  351","line":"  end"},
{"lineNum":"  352","line":""},
{"lineNum":"  353","line":"  def inspect(io)"},
{"lineNum":"  354","line":"    to_s(io)"},
{"lineNum":"  355","line":"  end"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"  # Returns a hexstring representation of this slice, assuming it\'s"},
{"lineNum":"  358","line":"  # a `Slice(UInt8)`."},
{"lineNum":"  359","line":"  #"},
{"lineNum":"  360","line":"  # ```"},
{"lineNum":"  361","line":"  # slice = UInt8.slice(97, 62, 63, 8, 255)"},
{"lineNum":"  362","line":"  # slice.hexstring # => \"613e3f08ff\""},
{"lineNum":"  363","line":"  # ```"},
{"lineNum":"  364","line":"  def hexstring"},
{"lineNum":"  365","line":"    self.as(Slice(UInt8))"},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"    str_size = size * 2"},
{"lineNum":"  368","line":"    String.new(str_size) do |buffer|"},
{"lineNum":"  369","line":"      hexstring(buffer)"},
{"lineNum":"  370","line":"      {str_size, str_size}"},
{"lineNum":"  371","line":"    end"},
{"lineNum":"  372","line":"  end"},
{"lineNum":"  373","line":""},
{"lineNum":"  374","line":"  # :nodoc:"},
{"lineNum":"  375","line":"  def hexstring(buffer)"},
{"lineNum":"  376","line":"    self.as(Slice(UInt8))"},
{"lineNum":"  377","line":""},
{"lineNum":"  378","line":"    offset = 0"},
{"lineNum":"  379","line":"    each do |v|","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  380","line":"      buffer[offset] = to_hex(v >> 4)"},
{"lineNum":"  381","line":"      buffer[offset + 1] = to_hex(v & 0x0f)"},
{"lineNum":"  382","line":"      offset += 2"},
{"lineNum":"  383","line":"    end"},
{"lineNum":"  384","line":""},
{"lineNum":"  385","line":"    nil"},
{"lineNum":"  386","line":"  end"},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"  # Returns a hexdump of this slice, assuming it\'s a `Slice(UInt8)`."},
{"lineNum":"  389","line":"  # This method is specially useful for debugging binary data and"},
{"lineNum":"  390","line":"  # incoming/outgoing data in protocols."},
{"lineNum":"  391","line":"  #"},
{"lineNum":"  392","line":"  # ```"},
{"lineNum":"  393","line":"  # slice = UInt8.slice(97, 62, 63, 8, 255)"},
{"lineNum":"  394","line":"  # slice.hexdump # => \"00000000  61 3e 3f 08 ff                                    a>?..\""},
{"lineNum":"  395","line":"  # ```"},
{"lineNum":"  396","line":"  def hexdump"},
{"lineNum":"  397","line":"    self.as(Slice(UInt8))"},
{"lineNum":"  398","line":""},
{"lineNum":"  399","line":"    return \"\" if empty?"},
{"lineNum":"  400","line":""},
{"lineNum":"  401","line":"    full_lines, leftover = size.divmod(16)"},
{"lineNum":"  402","line":"    if leftover == 0","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  403","line":"      str_size = full_lines * 77 - 1"},
{"lineNum":"  404","line":"      lines = full_lines","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  405","line":"    else"},
{"lineNum":"  406","line":"      str_size = (full_lines + 1) * 77 - (16 - leftover) - 1"},
{"lineNum":"  407","line":"      lines = full_lines + 1"},
{"lineNum":"  408","line":"    end"},
{"lineNum":"  409","line":""},
{"lineNum":"  410","line":"    String.new(str_size) do |buf|"},
{"lineNum":"  411","line":"      index_offset = 0"},
{"lineNum":"  412","line":"      hex_offset = 10"},
{"lineNum":"  413","line":"      ascii_offset = 60"},
{"lineNum":"  414","line":""},
{"lineNum":"  415","line":"      # Ensure we don\'t write outside the buffer:"},
{"lineNum":"  416","line":"      # slower, but safer (speed is not very important when hexdump is used)"},
{"lineNum":"  417","line":"      buffer = Slice.new(buf, str_size)"},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":"      each_with_index do |v, i|"},
{"lineNum":"  420","line":"        if i % 16 == 0","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  421","line":"          0.upto(7) do |j|"},
{"lineNum":"  422","line":"            buffer[index_offset + 7 - j] = to_hex((i >> (4 * j)) & 0xf)","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  423","line":"          end"},
{"lineNum":"  424","line":"          buffer[index_offset + 8] = \' \'.ord.to_u8"},
{"lineNum":"  425","line":"          buffer[index_offset + 9] = \' \'.ord.to_u8","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  426","line":"          index_offset += 77"},
{"lineNum":"  427","line":"        end"},
{"lineNum":"  428","line":""},
{"lineNum":"  429","line":"        buffer[hex_offset] = to_hex(v >> 4)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  430","line":"        buffer[hex_offset + 1] = to_hex(v & 0x0f)"},
{"lineNum":"  431","line":"        buffer[hex_offset + 2] = \' \'.ord.to_u8","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  432","line":"        hex_offset += 3"},
{"lineNum":"  433","line":""},
{"lineNum":"  434","line":"        buffer[ascii_offset] = (v > 31 && v < 127) ? v : \'.\'.ord.to_u8","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  435","line":"        ascii_offset += 1"},
{"lineNum":"  436","line":""},
{"lineNum":"  437","line":"        if i % 8 == 7","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  438","line":"          buffer[hex_offset] = \' \'.ord.to_u8","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  439","line":"          hex_offset += 1"},
{"lineNum":"  440","line":"        end"},
{"lineNum":"  441","line":""},
{"lineNum":"  442","line":"        if i % 16 == 15 && ascii_offset < str_size"},
{"lineNum":"  443","line":"          buffer[ascii_offset] = \'\\n\'.ord.to_u8","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  444","line":"          hex_offset += 27","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  445","line":"          ascii_offset += 61"},
{"lineNum":"  446","line":"        end"},
{"lineNum":"  447","line":"      end"},
{"lineNum":"  448","line":""},
{"lineNum":"  449","line":"      while hex_offset % 77 < 60","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  450","line":"        buffer[hex_offset] = \' \'.ord.to_u8","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  451","line":"        hex_offset += 1"},
{"lineNum":"  452","line":"      end"},
{"lineNum":"  453","line":""},
{"lineNum":"  454","line":"      {str_size, str_size}"},
{"lineNum":"  455","line":"    end"},
{"lineNum":"  456","line":"  end"},
{"lineNum":"  457","line":""},
{"lineNum":"  458","line":"  private def to_hex(c)"},
{"lineNum":"  459","line":"    ((c < 10 ? 48_u8 : 87_u8) + c)","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  460","line":"  end"},
{"lineNum":"  461","line":""},
{"lineNum":"  462","line":"  def bytesize"},
{"lineNum":"  463","line":"    sizeof(T) * size"},
{"lineNum":"  464","line":"  end"},
{"lineNum":"  465","line":""},
{"lineNum":"  466","line":"  def ==(other : self)"},
{"lineNum":"  467","line":"    return false if bytesize != other.bytesize","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  468","line":"    return LibC.memcmp(to_unsafe.as(Void*), other.to_unsafe.as(Void*), bytesize) == 0","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  469","line":"  end"},
{"lineNum":"  470","line":""},
{"lineNum":"  471","line":"  def to_slice"},
{"lineNum":"  472","line":"    self"},
{"lineNum":"  473","line":"  end"},
{"lineNum":"  474","line":""},
{"lineNum":"  475","line":"  def to_s(io)"},
{"lineNum":"  476","line":"    if T == UInt8"},
{"lineNum":"  477","line":"      io << \"Bytes\""},
{"lineNum":"  478","line":"      io << \"[\""},
{"lineNum":"  479","line":"      # Inspect using to_s because we know this is a UInt8."},
{"lineNum":"  480","line":"      join \", \", io, &.to_s(io)"},
{"lineNum":"  481","line":"      io << \"]\""},
{"lineNum":"  482","line":"    else"},
{"lineNum":"  483","line":"      io << \"Slice\""},
{"lineNum":"  484","line":"      io << \"[\""},
{"lineNum":"  485","line":"      join \", \", io, &.inspect(io)"},
{"lineNum":"  486","line":"      io << \"]\""},
{"lineNum":"  487","line":"    end"},
{"lineNum":"  488","line":"  end"},
{"lineNum":"  489","line":""},
{"lineNum":"  490","line":"  def pretty_print(pp) : Nil"},
{"lineNum":"  491","line":"    prefix = T == UInt8 ? \"Bytes[\" : \"Slice[\""},
{"lineNum":"  492","line":"    pp.list(prefix, self, \"]\")"},
{"lineNum":"  493","line":"  end"},
{"lineNum":"  494","line":""},
{"lineNum":"  495","line":"  def to_a"},
{"lineNum":"  496","line":"    Array(T).build(@size) do |pointer|"},
{"lineNum":"  497","line":"      pointer.copy_from(@pointer, @size)"},
{"lineNum":"  498","line":"      @size"},
{"lineNum":"  499","line":"    end"},
{"lineNum":"  500","line":"  end"},
{"lineNum":"  501","line":""},
{"lineNum":"  502","line":"  # Returns this slice\'s pointer."},
{"lineNum":"  503","line":"  #"},
{"lineNum":"  504","line":"  # ```"},
{"lineNum":"  505","line":"  # slice = Slice.new(3, 10)"},
{"lineNum":"  506","line":"  # slice.to_unsafe[0] # => 10"},
{"lineNum":"  507","line":"  # ```"},
{"lineNum":"  508","line":"  def to_unsafe : Pointer(T)"},
{"lineNum":"  509","line":"    @pointer"},
{"lineNum":"  510","line":"  end"},
{"lineNum":"  511","line":""},
{"lineNum":"  512","line":"  # :nodoc:"},
{"lineNum":"  513","line":"  def index(object, offset : Int = 0)"},
{"lineNum":"  514","line":"    # Optimize for the case of looking for a byte in a byte slice"},
{"lineNum":"  515","line":"    if T.is_a?(UInt8.class) &&"},
{"lineNum":"  516","line":"       (object.is_a?(UInt8) || (object.is_a?(Int) && 0 <= object < 256))"},
{"lineNum":"  517","line":"      return fast_index(object, offset)"},
{"lineNum":"  518","line":"    end"},
{"lineNum":"  519","line":""},
{"lineNum":"  520","line":"    super"},
{"lineNum":"  521","line":"  end"},
{"lineNum":"  522","line":""},
{"lineNum":"  523","line":"  # :nodoc:"},
{"lineNum":"  524","line":"  def fast_index(object, offset)"},
{"lineNum":"  525","line":"    offset += size if offset < 0"},
{"lineNum":"  526","line":"    if 0 <= offset < size"},
{"lineNum":"  527","line":"      result = LibC.memchr(to_unsafe + offset, object, size - offset)","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  528","line":"      if result","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  529","line":"        return (result - to_unsafe.as(Void*)).to_i32"},
{"lineNum":"  530","line":"      end"},
{"lineNum":"  531","line":"    end"},
{"lineNum":"  532","line":""},
{"lineNum":"  533","line":"    nil"},
{"lineNum":"  534","line":"  end"},
{"lineNum":"  535","line":""},
{"lineNum":"  536","line":"  # See `Object#hash(hasher)`"},
{"lineNum":"  537","line":"  def hash(hasher)"},
{"lineNum":"  538","line":"    {% if T == UInt8 %}"},
{"lineNum":"  539","line":"      hasher.bytes(self)"},
{"lineNum":"  540","line":"    {% else %}"},
{"lineNum":"  541","line":"      super hasher"},
{"lineNum":"  542","line":"    {% end %}"},
{"lineNum":"  543","line":"  end"},
{"lineNum":"  544","line":""},
{"lineNum":"  545","line":"  protected def check_writable"},
{"lineNum":"  546","line":"    raise \"Can\'t write to read-only Slice\" if @read_only","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  547","line":"  end"},
{"lineNum":"  548","line":"end"},
{"lineNum":"  549","line":""},
{"lineNum":"  550","line":"# A convenient alias for the most common slice type,"},
{"lineNum":"  551","line":"# a slice of bytes, used for example in `IO#read` and `IO#write`."},
{"lineNum":"  552","line":"alias Bytes = Slice(UInt8)"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "roman_spec", "date" : "2018-03-12 14:24:04", "instrumented" : 33, "covered" : 0,};
var merged_data = [];
