var data = {lines:[
{"lineNum":"    1","line":"# The `IO::Buffered` mixin enhances an `IO` with input/output buffering."},
{"lineNum":"    2","line":"#"},
{"lineNum":"    3","line":"# The buffering behaviour can be turned on/off with the `#sync=` method."},
{"lineNum":"    4","line":"#"},
{"lineNum":"    5","line":"# Additionally, several methods, like `#gets`, are implemented in a more"},
{"lineNum":"    6","line":"# efficient way."},
{"lineNum":"    7","line":"module IO::Buffered"},
{"lineNum":"    8","line":"  BUFFER_SIZE = 8192"},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"  @in_buffer_rem = Bytes.empty"},
{"lineNum":"   11","line":"  @out_count = 0"},
{"lineNum":"   12","line":"  @sync = false"},
{"lineNum":"   13","line":"  @flush_on_newline = false"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"  # Reads at most *slice.size* bytes from the wrapped `IO` into *slice*."},
{"lineNum":"   16","line":"  # Returns the number of bytes read."},
{"lineNum":"   17","line":"  abstract def unbuffered_read(slice : Bytes)"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"  # Writes at most *slice.size* bytes from *slice* into the wrapped `IO`."},
{"lineNum":"   20","line":"  # Returns the number of bytes written."},
{"lineNum":"   21","line":"  abstract def unbuffered_write(slice : Bytes)"},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"  # Flushes the wrapped `IO`."},
{"lineNum":"   24","line":"  abstract def unbuffered_flush"},
{"lineNum":"   25","line":""},
{"lineNum":"   26","line":"  # Closes the wrapped `IO`."},
{"lineNum":"   27","line":"  abstract def unbuffered_close"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"  # Rewinds the wrapped `IO`."},
{"lineNum":"   30","line":"  abstract def unbuffered_rewind"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"  # :nodoc:"},
{"lineNum":"   33","line":"  def read_byte : UInt8?","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   34","line":"    check_open"},
{"lineNum":"   35","line":""},
{"lineNum":"   36","line":"    fill_buffer if @in_buffer_rem.empty?","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   37","line":"    if @in_buffer_rem.empty?"},
{"lineNum":"   38","line":"      nil"},
{"lineNum":"   39","line":"    else"},
{"lineNum":"   40","line":"      b = @in_buffer_rem[0]"},
{"lineNum":"   41","line":"      @in_buffer_rem += 1","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   42","line":"      b"},
{"lineNum":"   43","line":"    end"},
{"lineNum":"   44","line":"  end"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"  # Buffered implementation of `IO#read(slice)`."},
{"lineNum":"   47","line":"  def read(slice : Bytes)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   48","line":"    check_open"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"    count = slice.size"},
{"lineNum":"   51","line":"    return 0 if count == 0","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   52","line":""},
{"lineNum":"   53","line":"    if @in_buffer_rem.empty?","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   54","line":"      # If we are asked to read more than half the buffer\'s size,"},
{"lineNum":"   55","line":"      # read directly into the slice, as it\'s not worth the extra"},
{"lineNum":"   56","line":"      # memory copy."},
{"lineNum":"   57","line":"      if count >= BUFFER_SIZE / 2","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   58","line":"        return unbuffered_read(slice[0, count]).to_i","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   59","line":"      else"},
{"lineNum":"   60","line":"        fill_buffer"},
{"lineNum":"   61","line":"        return 0 if @in_buffer_rem.empty?"},
{"lineNum":"   62","line":"      end"},
{"lineNum":"   63","line":"    end"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"    to_read = Math.min(count, @in_buffer_rem.size)"},
{"lineNum":"   66","line":"    slice.copy_from(@in_buffer_rem.pointer(to_read), to_read)"},
{"lineNum":"   67","line":"    @in_buffer_rem += to_read","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   68","line":"    to_read"},
{"lineNum":"   69","line":"  end"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"  # Returns the bytes hold in the read buffer."},
{"lineNum":"   72","line":"  #"},
{"lineNum":"   73","line":"  # This method only performs a read to return"},
{"lineNum":"   74","line":"  # peek data if the current buffer is empty:"},
{"lineNum":"   75","line":"  # otherwise no read is performed and whatever"},
{"lineNum":"   76","line":"  # is in the buffer is returned."},
{"lineNum":"   77","line":"  def peek : Bytes?"},
{"lineNum":"   78","line":"    check_open"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"    if @in_buffer_rem.empty?","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   81","line":"      fill_buffer"},
{"lineNum":"   82","line":"      if @in_buffer_rem.empty?"},
{"lineNum":"   83","line":"        return Bytes.empty # EOF","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   84","line":"      end"},
{"lineNum":"   85","line":"    end"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"    @in_buffer_rem"},
{"lineNum":"   88","line":"  end"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"  # :nodoc:"},
{"lineNum":"   91","line":"  def skip(bytes_count) : Nil","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   92","line":"    check_open"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"    if bytes_count <= @in_buffer_rem.size","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   95","line":"      @in_buffer_rem += bytes_count","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   96","line":"      return"},
{"lineNum":"   97","line":"    end"},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"    bytes_count -= @in_buffer_rem.size"},
{"lineNum":"  100","line":"    @in_buffer_rem = Bytes.empty","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"    super(bytes_count)"},
{"lineNum":"  103","line":"  end"},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"  # Buffered implementation of `IO#write(slice)`."},
{"lineNum":"  106","line":"  def write(slice : Bytes)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  107","line":"    check_open"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"    count = slice.size"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"    if sync?","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  112","line":"      return unbuffered_write(slice)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  113","line":"    end"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"    if flush_on_newline?","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  116","line":"      index = slice[0, count.to_i32].rindex(\'\\n\'.ord.to_u8)"},
{"lineNum":"  117","line":"      if index"},
{"lineNum":"  118","line":"        flush"},
{"lineNum":"  119","line":"        index += 1"},
{"lineNum":"  120","line":"        unbuffered_write slice[0, index]","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  121","line":"        slice += index"},
{"lineNum":"  122","line":"        count -= index","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  123","line":"      end"},
{"lineNum":"  124","line":"    end"},
{"lineNum":"  125","line":""},
{"lineNum":"  126","line":"    if count >= BUFFER_SIZE","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  127","line":"      flush"},
{"lineNum":"  128","line":"      return unbuffered_write slice[0, count]"},
{"lineNum":"  129","line":"    end"},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"    if count > BUFFER_SIZE - @out_count","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  132","line":"      flush"},
{"lineNum":"  133","line":"    end"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"    slice.copy_to(out_buffer + @out_count, count)"},
{"lineNum":"  136","line":"    @out_count += count","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  137","line":"    nil"},
{"lineNum":"  138","line":"  end"},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"  # :nodoc:"},
{"lineNum":"  141","line":"  def write_byte(byte : UInt8)"},
{"lineNum":"  142","line":"    check_open"},
{"lineNum":"  143","line":""},
{"lineNum":"  144","line":"    if sync?","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  145","line":"      return super"},
{"lineNum":"  146","line":"    end"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"    if @out_count >= BUFFER_SIZE","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  149","line":"      flush","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  150","line":"    end"},
{"lineNum":"  151","line":"    out_buffer[@out_count] = byte","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  152","line":"    @out_count += 1","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  153","line":""},
{"lineNum":"  154","line":"    if flush_on_newline? && byte === \'\\n\'"},
{"lineNum":"  155","line":"      flush","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  156","line":"    end"},
{"lineNum":"  157","line":"  end"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"  # Turns on/off flushing the underlying `IO` when a newline is written."},
{"lineNum":"  160","line":"  def flush_on_newline=(flush_on_newline)"},
{"lineNum":"  161","line":"    @flush_on_newline = !!flush_on_newline","class":"lineNoCov","hits":"0","possible_hits":"50",},
{"lineNum":"  162","line":"  end"},
{"lineNum":"  163","line":""},
{"lineNum":"  164","line":"  # Determines if this `IO` flushes automatically when a newline is written."},
{"lineNum":"  165","line":"  def flush_on_newline?"},
{"lineNum":"  166","line":"    @flush_on_newline"},
{"lineNum":"  167","line":"  end"},
{"lineNum":"  168","line":""},
{"lineNum":"  169","line":"  # Turns on/off `IO` buffering. When *sync* is set to `true`, no buffering"},
{"lineNum":"  170","line":"  # will be done (that is, writing to this `IO` is immediately synced to the"},
{"lineNum":"  171","line":"  # underlying `IO`)."},
{"lineNum":"  172","line":"  def sync=(sync)"},
{"lineNum":"  173","line":"    flush if sync && !@sync","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  174","line":"    @sync = !!sync","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  175","line":"  end"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"  # Determines if this `IO` does buffering. If `true`, no buffering is done."},
{"lineNum":"  178","line":"  def sync?"},
{"lineNum":"  179","line":"    @sync"},
{"lineNum":"  180","line":"  end"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"  # Flushes any buffered data and the underlying `IO`. Returns `self`."},
{"lineNum":"  183","line":"  def flush","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  184","line":"    unbuffered_write(Slice.new(out_buffer, @out_count)) if @out_count > 0","class":"lineNoCov","hits":"0","possible_hits":"60",},
{"lineNum":"  185","line":"    unbuffered_flush"},
{"lineNum":"  186","line":"    @out_count = 0","class":"lineNoCov","hits":"0","possible_hits":"32",},
{"lineNum":"  187","line":"    self"},
{"lineNum":"  188","line":"  end"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"  # Flushes and closes the underlying `IO`."},
{"lineNum":"  191","line":"  def close : Nil","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  192","line":"    flush if @out_count > 0","class":"lineNoCov","hits":"0","possible_hits":"36",},
{"lineNum":"  193","line":"  ensure"},
{"lineNum":"  194","line":"    unbuffered_close","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  195","line":"  end"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"  # Rewinds the underlying `IO`. Returns `self`."},
{"lineNum":"  198","line":"  def rewind"},
{"lineNum":"  199","line":"    unbuffered_rewind"},
{"lineNum":"  200","line":"    @in_buffer_rem = Bytes.empty"},
{"lineNum":"  201","line":"    self"},
{"lineNum":"  202","line":"  end"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"  private def fill_buffer"},
{"lineNum":"  205","line":"    in_buffer = in_buffer()"},
{"lineNum":"  206","line":"    size = unbuffered_read(Slice.new(in_buffer, BUFFER_SIZE)).to_i","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  207","line":"    @in_buffer_rem = Slice.new(in_buffer, size)","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  208","line":"  end"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"  private def in_buffer"},
{"lineNum":"  211","line":"    @in_buffer ||= GC.malloc_atomic(BUFFER_SIZE.to_u32).as(UInt8*)","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  212","line":"  end"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"  private def out_buffer","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  215","line":"    @out_buffer ||= GC.malloc_atomic(BUFFER_SIZE.to_u32).as(UInt8*)","class":"lineNoCov","hits":"0","possible_hits":"84",},
{"lineNum":"  216","line":"  end"},
{"lineNum":"  217","line":"end"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "roman_spec", "date" : "2018-03-12 14:24:04", "instrumented" : 44, "covered" : 0,};
var merged_data = [];
