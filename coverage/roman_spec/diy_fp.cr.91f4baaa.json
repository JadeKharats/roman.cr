var data = {lines:[
{"lineNum":"    1","line":"# DiyFP is ported from the C++ \"double-conversions\" library."},
{"lineNum":"    2","line":"# The following is their license:"},
{"lineNum":"    3","line":"#   Copyright 2010 the V8 project authors. All rights reserved."},
{"lineNum":"    4","line":"#   Redistribution and use in source and binary forms, with or without"},
{"lineNum":"    5","line":"#   modification, are permitted provided that the following conditions are"},
{"lineNum":"    6","line":"#   met:"},
{"lineNum":"    7","line":"#"},
{"lineNum":"    8","line":"#       * Redistributions of source code must retain the above copyright"},
{"lineNum":"    9","line":"#         notice, this list of conditions and the following disclaimer."},
{"lineNum":"   10","line":"#       * Redistributions in binary form must reproduce the above"},
{"lineNum":"   11","line":"#         copyright notice, this list of conditions and the following"},
{"lineNum":"   12","line":"#         disclaimer in the documentation and/or other materials provided"},
{"lineNum":"   13","line":"#         with the distribution."},
{"lineNum":"   14","line":"#       * Neither the name of Google Inc. nor the names of its"},
{"lineNum":"   15","line":"#         contributors may be used to endorse or promote products derived"},
{"lineNum":"   16","line":"#         from this software without specific prior written permission."},
{"lineNum":"   17","line":"#"},
{"lineNum":"   18","line":"#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS"},
{"lineNum":"   19","line":"#   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT"},
{"lineNum":"   20","line":"#   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR"},
{"lineNum":"   21","line":"#   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT"},
{"lineNum":"   22","line":"#   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,"},
{"lineNum":"   23","line":"#   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT"},
{"lineNum":"   24","line":"#   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,"},
{"lineNum":"   25","line":"#   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY"},
{"lineNum":"   26","line":"#   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT"},
{"lineNum":"   27","line":"#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE"},
{"lineNum":"   28","line":"#   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"require \"./ieee\""},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"# This \"Do It Yourself Floating Point\" struct implements a floating-point number"},
{"lineNum":"   33","line":"# with a `UIht64` significand and an `Int32` exponent. Normalized DiyFP numbers will"},
{"lineNum":"   34","line":"# have the most significant bit of the significand set."},
{"lineNum":"   35","line":"# Multiplication and Subtraction do not normalize their results."},
{"lineNum":"   36","line":"# DiyFP is not designed to contain special Floats (NaN and Infinity)."},
{"lineNum":"   37","line":"struct Float::Printer::DiyFP"},
{"lineNum":"   38","line":"  SIGNIFICAND_SIZE = 64"},
{"lineNum":"   39","line":"  # Also known as the significand"},
{"lineNum":"   40","line":"  property frac : UInt64"},
{"lineNum":"   41","line":"  # exponent"},
{"lineNum":"   42","line":"  property exp : Int32"},
{"lineNum":"   43","line":""},
{"lineNum":"   44","line":"  def initialize(@frac, @exp)"},
{"lineNum":"   45","line":"  end"},
{"lineNum":"   46","line":""},
{"lineNum":"   47","line":"  def initialize(@frac, exp : Int16)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   48","line":"    @exp = exp.to_i32"},
{"lineNum":"   49","line":"  end"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"  def new(frac : Int32, exp)"},
{"lineNum":"   52","line":"    new frac.to_u64, exp"},
{"lineNum":"   53","line":"  end"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"  # Returns a new `DiyFP` caculated as self - *other*."},
{"lineNum":"   56","line":"  #"},
{"lineNum":"   57","line":"  # The exponents of both numbers must be the same and the frac of self must be"},
{"lineNum":"   58","line":"  # greater than the other."},
{"lineNum":"   59","line":"  #"},
{"lineNum":"   60","line":"  # This result is not normalized."},
{"lineNum":"   61","line":"  def -(other : DiyFP)","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   62","line":"    _invariant self.exp == other.exp && frac >= other.frac"},
{"lineNum":"   63","line":"    self.class.new(frac - other.frac, exp)"},
{"lineNum":"   64","line":"  end"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"  MASK32 = 0xFFFFFFFF_u32"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"  # Returns a new `DiyFP` caculated as self * *other*."},
{"lineNum":"   69","line":"  #"},
{"lineNum":"   70","line":"  # Simply \"emulates\" a 128 bit multiplication."},
{"lineNum":"   71","line":"  # However: the resulting number only contains 64 bits. The least"},
{"lineNum":"   72","line":"  # significant 64 bits are only used for rounding the most significant 64"},
{"lineNum":"   73","line":"  # bits."},
{"lineNum":"   74","line":"  #"},
{"lineNum":"   75","line":"  # This result is not normalized."},
{"lineNum":"   76","line":"  def *(other : DiyFP)"},
{"lineNum":"   77","line":"    a = frac >> 32","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   78","line":"    b = frac & MASK32"},
{"lineNum":"   79","line":"    c = other.frac >> 32","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   80","line":"    d = other.frac & MASK32","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   81","line":"    ac = a*c","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   82","line":"    bc = b*c","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   83","line":"    ad = a*d","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   84","line":"    bd = b*d"},
{"lineNum":"   85","line":"    tmp = (bd >> 32) + (ad & MASK32) + (bc & MASK32)","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   86","line":"    # By adding 1U << 31 to tmp we round the final result."},
{"lineNum":"   87","line":"    # Halfway cases will be round up."},
{"lineNum":"   88","line":"    tmp += 1_u32 << 31","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   89","line":"    f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32)","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"   90","line":"    e = exp + other.exp + 64"},
{"lineNum":"   91","line":""},
{"lineNum":"   92","line":"    self.class.new(f, e)"},
{"lineNum":"   93","line":"  end"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"  def normalize"},
{"lineNum":"   96","line":"    _invariant frac != 0"},
{"lineNum":"   97","line":"    f = frac"},
{"lineNum":"   98","line":"    e = exp"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"    # This method is mainly called for normalizing boundaries. In general"},
{"lineNum":"  101","line":"    # boundaries need to be shifted by 10 bits. We thus optimize for this case."},
{"lineNum":"  102","line":"    k10MSBits = 0xFFC0000000000000_u64"},
{"lineNum":"  103","line":"    kUint64MSB = 0x8000000000000000_u64"},
{"lineNum":"  104","line":"    while (f & k10MSBits) == 0"},
{"lineNum":"  105","line":"      # puts \"  sig: #{f}\""},
{"lineNum":"  106","line":"      #  puts \"  exp: #{e}\""},
{"lineNum":"  107","line":"      f <<= 10_u64","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  108","line":"      e -= 10"},
{"lineNum":"  109","line":"    end"},
{"lineNum":"  110","line":"    while (f & kUint64MSB) == 0"},
{"lineNum":"  111","line":"      # puts \"  sig: #{f}\""},
{"lineNum":"  112","line":"      # puts \"  exp: #{e}\""},
{"lineNum":"  113","line":"      f <<= 1_u64","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  114","line":"      e -= 1"},
{"lineNum":"  115","line":"    end"},
{"lineNum":"  116","line":"    DiyFP.new(f, e)"},
{"lineNum":"  117","line":"  end"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"  def self.from_f(d : Float64 | Float32)"},
{"lineNum":"  120","line":"    _invariant d > 0"},
{"lineNum":"  121","line":"    frac, exp = IEEE.frac_and_exp(d)"},
{"lineNum":"  122","line":"    new(frac, exp)"},
{"lineNum":"  123","line":"  end"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"  # Normalize such that the most signficiant bit of frac is set"},
{"lineNum":"  126","line":"  def self.from_f_normalized(v : Float64 | Float32)"},
{"lineNum":"  127","line":"    pre_normalized = from_f(v)"},
{"lineNum":"  128","line":"    f = pre_normalized.frac"},
{"lineNum":"  129","line":"    e = pre_normalized.exp"},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"    # could be a denormal"},
{"lineNum":"  132","line":"    while (f & IEEE::HIDDEN_BIT_64) == 0"},
{"lineNum":"  133","line":"      f <<= 1","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  134","line":"      e -= 1"},
{"lineNum":"  135","line":"    end"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"    # do the final shifts in one go"},
{"lineNum":"  138","line":"    f <<= DiyFP::SIGNIFICAND_SIZE - IEEE::SIGNIFICAND_SIZE_64"},
{"lineNum":"  139","line":"    e -= DiyFP::SIGNIFICAND_SIZE - IEEE::SIGNIFICAND_SIZE_64"},
{"lineNum":"  140","line":"    DiyFP.new(f, e)"},
{"lineNum":"  141","line":"  end"},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"  private macro _invariant(exp, file = __FILE__, line = __LINE__)"},
{"lineNum":"  144","line":"    {% if !flag?(:release) %}"},
{"lineNum":"  145","line":"      unless {{exp}}"},
{"lineNum":"  146","line":"        raise \"Assertion Failed #{{{file}}}:#{{{line}}}\""},
{"lineNum":"  147","line":"      end"},
{"lineNum":"  148","line":"    {% end %}"},
{"lineNum":"  149","line":"  end"},
{"lineNum":"  150","line":"end"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "roman_spec", "date" : "2018-03-12 14:57:27", "instrumented" : 14, "covered" : 0,};
var merged_data = [];
