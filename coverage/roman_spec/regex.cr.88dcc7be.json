var data = {lines:[
{"lineNum":"    1","line":"require \"./regex/*\""},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"# A `Regex` represents a regular expression, a pattern that describes the"},
{"lineNum":"    4","line":"# contents of strings. A `Regex` can determine whether or not a string matches"},
{"lineNum":"    5","line":"# its description, and extract the parts of the string that match."},
{"lineNum":"    6","line":"#"},
{"lineNum":"    7","line":"# A `Regex` can be created using the literal syntax, in which it is delimited by"},
{"lineNum":"    8","line":"# forward slashes (`/`):"},
{"lineNum":"    9","line":"#"},
{"lineNum":"   10","line":"# ```"},
{"lineNum":"   11","line":"# /hay/ =~ \"haystack\"   # => 0"},
{"lineNum":"   12","line":"# /y/.match(\"haystack\") # => #<Regex::MatchData \"y\">"},
{"lineNum":"   13","line":"# ```"},
{"lineNum":"   14","line":"#"},
{"lineNum":"   15","line":"# Interpolation works in regular expression literals just as it does in string"},
{"lineNum":"   16","line":"# literals. Be aware that using this feature will cause an exception to be"},
{"lineNum":"   17","line":"# raised at runtime, if the resulting string would not be a valid regular"},
{"lineNum":"   18","line":"# expression."},
{"lineNum":"   19","line":"#"},
{"lineNum":"   20","line":"# ```"},
{"lineNum":"   21","line":"# x = \"a\""},
{"lineNum":"   22","line":"# /#{x}/.match(\"asdf\") # => #<Regex::MatchData \"a\">"},
{"lineNum":"   23","line":"# x = \"(\""},
{"lineNum":"   24","line":"# /#{x}/ # raises ArgumentError"},
{"lineNum":"   25","line":"# ```"},
{"lineNum":"   26","line":"#"},
{"lineNum":"   27","line":"# When we check to see if a particular regular expression describes a string,"},
{"lineNum":"   28","line":"# we can say that we are performing a match or matching one against the other.","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   29","line":"# If we find that a regular expression does describe a string, we say that it"},
{"lineNum":"   30","line":"# matches, and we can refer to a part of the string that was described as"},
{"lineNum":"   31","line":"# a match."},
{"lineNum":"   32","line":"#"},
{"lineNum":"   33","line":"# Here `\"haystack\"` does not contain the pattern `/needle/`, so it doesn\'t match:"},
{"lineNum":"   34","line":"#"},
{"lineNum":"   35","line":"# ```"},
{"lineNum":"   36","line":"# /needle/.match(\"haystack\") # => nil"},
{"lineNum":"   37","line":"# ```"},
{"lineNum":"   38","line":"#"},
{"lineNum":"   39","line":"# Here `\"haystack\"` contains the pattern `/hay/`, so it matches:"},
{"lineNum":"   40","line":"#"},
{"lineNum":"   41","line":"# ```"},
{"lineNum":"   42","line":"# /hay/.match(\"haystack\") # => #<Regex::MatchData \"hay\">"},
{"lineNum":"   43","line":"# ```"},
{"lineNum":"   44","line":"#"},
{"lineNum":"   45","line":"# Regex methods that perform a match usually return a truthy value if there was"},
{"lineNum":"   46","line":"# a match and `nil` if there was no match. After performing a match, the"},
{"lineNum":"   47","line":"# special variable `$~` will be an instance of `Regex::MatchData` if it matched, `nil`"},
{"lineNum":"   48","line":"# otherwise."},
{"lineNum":"   49","line":"#"},
{"lineNum":"   50","line":"# When matching a regular expression using `=~` (either `String#=~` or"},
{"lineNum":"   51","line":"# `Regex#=~`), the returned value will be the index of the first match in the"},
{"lineNum":"   52","line":"# string if the expression matched, `nil` otherwise."},
{"lineNum":"   53","line":"#"},
{"lineNum":"   54","line":"# ```"},
{"lineNum":"   55","line":"# /stack/ =~ \"haystack\"  # => 3"},
{"lineNum":"   56","line":"# \"haystack\" =~ /stack/  # => 3"},
{"lineNum":"   57","line":"# $~                     # => #<Regex::MatchData \"stack\">"},
{"lineNum":"   58","line":"# /needle/ =~ \"haystack\" # => nil"},
{"lineNum":"   59","line":"# \"haystack\" =~ /needle/ # => nil"},
{"lineNum":"   60","line":"# $~                     # raises Exception"},
{"lineNum":"   61","line":"# ```"},
{"lineNum":"   62","line":"#"},
{"lineNum":"   63","line":"# When matching a regular expression using `#match` (either `String#match` or"},
{"lineNum":"   64","line":"# `Regex#match`), the returned value will be a `Regex::MatchData` if the expression"},
{"lineNum":"   65","line":"# matched, `nil` otherwise."},
{"lineNum":"   66","line":"#"},
{"lineNum":"   67","line":"# ```"},
{"lineNum":"   68","line":"# /hay/.match(\"haystack\")    # => #<Regex::MatchData \"hay\">"},
{"lineNum":"   69","line":"# \"haystack\".match(/hay/)    # => #<Regex::MatchData \"hay\">"},
{"lineNum":"   70","line":"# $~                         # => #<Regex::MatchData \"hay\">"},
{"lineNum":"   71","line":"# /needle/.match(\"haystack\") # => nil"},
{"lineNum":"   72","line":"# \"haystack\".match(/needle/) # => nil"},
{"lineNum":"   73","line":"# $~                         # raises Exception"},
{"lineNum":"   74","line":"# ```"},
{"lineNum":"   75","line":"#"},
{"lineNum":"   76","line":"# [Regular expressions](https://en.wikipedia.org/wiki/Regular_expression)"},
{"lineNum":"   77","line":"# have their own language for describing strings."},
{"lineNum":"   78","line":"#"},
{"lineNum":"   79","line":"# Many programming languages and tools implement their own regular expression"},
{"lineNum":"   80","line":"# language, but Crystal uses [PCRE](http://www.pcre.org/), a popular C library"},
{"lineNum":"   81","line":"# for providing regular expressions. Here give a brief summary of the most"},
{"lineNum":"   82","line":"# basic features of regular expressions - grouping, repetition, and"},
{"lineNum":"   83","line":"# alternation - but the feature set of PCRE extends far beyond these, and we"},
{"lineNum":"   84","line":"# don\'t attempt to describe it in full here. For more information, refer to"},
{"lineNum":"   85","line":"# the PCRE documentation, especially the"},
{"lineNum":"   86","line":"# [full pattern syntax](http://www.pcre.org/original/doc/html/pcrepattern.html)"},
{"lineNum":"   87","line":"# or"},
{"lineNum":"   88","line":"# [syntax quick reference](http://www.pcre.org/original/doc/html/pcresyntax.html)."},
{"lineNum":"   89","line":"#"},
{"lineNum":"   90","line":"# The regular expression language can be used to match much more than just the"},
{"lineNum":"   91","line":"# static substrings in the above examples. Certain characters, called"},
{"lineNum":"   92","line":"# [metacharacters](http://www.pcre.org/original/doc/html/pcrepattern.html#SEC4),"},
{"lineNum":"   93","line":"# are given special treatment in regular expressions, and can be used to"},
{"lineNum":"   94","line":"# describe more complex patterns. To match metacharacters literally in a"},
{"lineNum":"   95","line":"# regular expression, they must be escaped by being preceded with a backslash"},
{"lineNum":"   96","line":"# (`\\`). `escape` will do this automatically for a given String."},
{"lineNum":"   97","line":"#"},
{"lineNum":"   98","line":"# A group of characters (often called a capture group or"},
{"lineNum":"   99","line":"# [subpattern](http://www.pcre.org/original/doc/html/pcrepattern.html#SEC14))"},
{"lineNum":"  100","line":"# can be identified by enclosing it in parentheses (`()`). The contents of"},
{"lineNum":"  101","line":"# each capture group can be extracted on a successful match:"},
{"lineNum":"  102","line":"#"},
{"lineNum":"  103","line":"# ```"},
{"lineNum":"  104","line":"# /a(sd)f/.match(\"_asdf_\")                     # => #<Regex::MatchData \"asdf\" 1:\"sd\">"},
{"lineNum":"  105","line":"# /a(sd)f/.match(\"_asdf_\").try &.[1]           # => \"sd\""},
{"lineNum":"  106","line":"# /a(?<grp>sd)f/.match(\"_asdf_\")               # => #<Regex::MatchData \"asdf\" grp:\"sd\">"},
{"lineNum":"  107","line":"# /a(?<grp>sd)f/.match(\"_asdf_\").try &.[\"grp\"] # => \"sd\""},
{"lineNum":"  108","line":"# ```"},
{"lineNum":"  109","line":"#"},
{"lineNum":"  110","line":"# Capture groups are indexed starting from 1. Methods that accept a capture"},
{"lineNum":"  111","line":"# group index will usually also accept 0 to refer to the full match. Capture"},
{"lineNum":"  112","line":"# groups can also be given names, using the `(?&lt;name&gt;...)` syntax, as in the"},
{"lineNum":"  113","line":"# previous example."},
{"lineNum":"  114","line":"#"},
{"lineNum":"  115","line":"# Following a match, the special variables $N (e.g., $1, $2, $3, ...) can be used"},
{"lineNum":"  116","line":"# to access a capture group. Trying to access an invalid capture group will raise an"},
{"lineNum":"  117","line":"# exception. Note that it is possible to have a successful match with a nil capture:"},
{"lineNum":"  118","line":"#"},
{"lineNum":"  119","line":"# ```"},
{"lineNum":"  120","line":"# /(spice)(s)?/.match(\"spice\") # => #<Regex::MatchData \"spice\" 1:\"spice\" 2:nil>"},
{"lineNum":"  121","line":"# $1                           # => \"spice\""},
{"lineNum":"  122","line":"# $2                           # => raises Exception"},
{"lineNum":"  123","line":"# ```"},
{"lineNum":"  124","line":"#"},
{"lineNum":"  125","line":"# This can be mitigated by using the nilable version of the above: $N?,"},
{"lineNum":"  126","line":"# (e.g., $1? $2?, $3?, ...). Changing the above to use `$2?` instead of `$2`"},
{"lineNum":"  127","line":"# would return `nil`. `$2?.nil?` would return `true`."},
{"lineNum":"  128","line":"#"},
{"lineNum":"  129","line":"# A character or group can be"},
{"lineNum":"  130","line":"# [repeated](http://www.pcre.org/original/doc/html/pcrepattern.html#SEC17)"},
{"lineNum":"  131","line":"# or made optional using an asterisk (`*` - zero or more), a plus sign"},
{"lineNum":"  132","line":"# (`+` - one or more), integer bounds in curly braces"},
{"lineNum":"  133","line":"# (`{n,m}`) (at least `n`, no more than `m`), or a question mark"},
{"lineNum":"  134","line":"# (`?`) (zero or one)."},
{"lineNum":"  135","line":"#"},
{"lineNum":"  136","line":"# ```"},
{"lineNum":"  137","line":"# /fo*/.match(\"_f_\")         # => #<Regex::MatchData \"f\">"},
{"lineNum":"  138","line":"# /fo+/.match(\"_f_\")         # => nil"},
{"lineNum":"  139","line":"# /fo*/.match(\"_foo_\")       # => #<Regex::MatchData \"foo\">"},
{"lineNum":"  140","line":"# /fo{3,}/.match(\"_foo_\")    # => nil"},
{"lineNum":"  141","line":"# /fo{1,3}/.match(\"_foo_\")   # => #<Regex::MatchData \"foo\">"},
{"lineNum":"  142","line":"# /fo*/.match(\"_foo_\")       # => #<Regex::MatchData \"foo\">"},
{"lineNum":"  143","line":"# /fo*/.match(\"_foooooooo_\") # => #<Regex::MatchData \"foooooooo\">"},
{"lineNum":"  144","line":"# /fo{,3}/.match(\"_foooo_\")  # => nil"},
{"lineNum":"  145","line":"# /f(op)*/.match(\"fopopo\")   # => #<Regex::MatchData \"fopop\" 1: \"op\">"},
{"lineNum":"  146","line":"# /foo?bar/.match(\"foobar\")  # => #<Regex::MatchData \"foobar\">"},
{"lineNum":"  147","line":"# /foo?bar/.match(\"fobar\")   # => #<Regex::MatchData \"fobar\">"},
{"lineNum":"  148","line":"# ```"},
{"lineNum":"  149","line":"#"},
{"lineNum":"  150","line":"# Alternatives can be separated using a"},
{"lineNum":"  151","line":"# [vertical bar](http://www.pcre.org/original/doc/html/pcrepattern.html#SEC12)"},
{"lineNum":"  152","line":"# (`|`). Any single character can be represented by"},
{"lineNum":"  153","line":"# [dot](http://www.pcre.org/original/doc/html/pcrepattern.html#SEC7)"},
{"lineNum":"  154","line":"# (`.`). When matching only one character, specific"},
{"lineNum":"  155","line":"# alternatives can be expressed as a"},
{"lineNum":"  156","line":"# [character class](http://www.pcre.org/original/doc/html/pcrepattern.html#SEC9),"},
{"lineNum":"  157","line":"# enclosed in square brackets (`[]`):"},
{"lineNum":"  158","line":"#"},
{"lineNum":"  159","line":"# ```"},
{"lineNum":"  160","line":"# /foo|bar/.match(\"foo\")     # => #<Regex::MatchData \"foo\">"},
{"lineNum":"  161","line":"# /foo|bar/.match(\"bar\")     # => #<Regex::MatchData \"bar\">"},
{"lineNum":"  162","line":"# /_(x|y)_/.match(\"_x_\")     # => #<Regex::MatchData \"_x_\" 1: \"x\">"},
{"lineNum":"  163","line":"# /_(x|y)_/.match(\"_y_\")     # => #<Regex::MatchData \"_y_\" 1: \"y\">"},
{"lineNum":"  164","line":"# /_(x|y)_/.match(\"_(x|y)_\") # => nil"},
{"lineNum":"  165","line":"# /_(x|y)_/.match(\"_(x|y)_\") # => nil"},
{"lineNum":"  166","line":"# /_._/.match(\"_x_\")         # => #<Regex::MatchData \"_x_\">"},
{"lineNum":"  167","line":"# /_[xyz]_/.match(\"_x_\")     # => #<Regex::MatchData \"_x_\">"},
{"lineNum":"  168","line":"# /_[a-z]_/.match(\"_x_\")     # => #<Regex::MatchData \"_x_\">"},
{"lineNum":"  169","line":"# /_[^a-z]_/.match(\"_x_\")    # => nil"},
{"lineNum":"  170","line":"# /_[^a-wy-z]_/.match(\"_x_\") # => #<Regex::MatchData \"_x_\">"},
{"lineNum":"  171","line":"# ```"},
{"lineNum":"  172","line":"#"},
{"lineNum":"  173","line":"# Regular expressions can be defined with these 3"},
{"lineNum":"  174","line":"# [optional flags](http://www.pcre.org/original/doc/html/pcreapi.html#SEC11):"},
{"lineNum":"  175","line":"#"},
{"lineNum":"  176","line":"# * `i`: ignore case (PCRE_CASELESS)"},
{"lineNum":"  177","line":"# * `m`: multiline (PCRE_MULTILINE and PCRE_DOTALL)"},
{"lineNum":"  178","line":"# * `x`: extended (PCRE_EXTENDED)"},
{"lineNum":"  179","line":"#"},
{"lineNum":"  180","line":"# ```"},
{"lineNum":"  181","line":"# /asdf/ =~ \"ASDF\"    # => nil"},
{"lineNum":"  182","line":"# /asdf/i =~ \"ASDF\"   # => 0"},
{"lineNum":"  183","line":"# /^z/i =~ \"ASDF\\nZ\"  # => nil","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  184","line":"# /^z/im =~ \"ASDF\\nZ\" # => 5"},
{"lineNum":"  185","line":"# ```"},
{"lineNum":"  186","line":"#"},
{"lineNum":"  187","line":"# PCRE supports other encodings, but Crystal strings are UTF-8 only, so Crystal"},
{"lineNum":"  188","line":"# regular expressions are also UTF-8 only (by default)."},
{"lineNum":"  189","line":"#"},
{"lineNum":"  190","line":"# PCRE optionally permits named capture groups (named subpatterns) to not be"},
{"lineNum":"  191","line":"# unique. Crystal exposes the name table of a `Regex` as a"},
{"lineNum":"  192","line":"# `Hash` of `String` => `Int32`, and therefore requires named capture groups to have"},
{"lineNum":"  193","line":"# unique names within a single `Regex`."},
{"lineNum":"  194","line":"class Regex"},
{"lineNum":"  195","line":"  @[Flags]"},
{"lineNum":"  196","line":"  enum Options"},
{"lineNum":"  197","line":"    IGNORE_CASE = 1"},
{"lineNum":"  198","line":"    # PCRE native `PCRE_MULTILINE` flag is `2`, and `PCRE_DOTALL` is `4`"},
{"lineNum":"  199","line":"    # - `PCRE_DOTALL` changes the \"`.`\" meaning"},
{"lineNum":"  200","line":"    # - `PCRE_MULTILINE` changes \"`^`\" and \"`$`\" meanings"},
{"lineNum":"  201","line":"    #"},
{"lineNum":"  202","line":"    # Crystal modifies this meaning to have essentially one unique \"`m`\""},
{"lineNum":"  203","line":"    # flag that activates both behaviours, so here we do the same by"},
{"lineNum":"  204","line":"    # mapping `MULTILINE` to `PCRE_MULTILINE | PCRE_DOTALL`."},
{"lineNum":"  205","line":"    MULTILINE = 6"},
{"lineNum":"  206","line":"    EXTENDED  = 8"},
{"lineNum":"  207","line":"    # :nodoc:"},
{"lineNum":"  208","line":"    ANCHORED = 16"},
{"lineNum":"  209","line":"    # :nodoc:"},
{"lineNum":"  210","line":"    UTF_8 = 0x00000800"},
{"lineNum":"  211","line":"    # :nodoc:"},
{"lineNum":"  212","line":"    NO_UTF8_CHECK = 0x00002000"},
{"lineNum":"  213","line":"    # :nodoc:"},
{"lineNum":"  214","line":"    DUPNAMES = 0x00080000"},
{"lineNum":"  215","line":"  end"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"  # Return a `Regex::Options` representing the optional flags applied to this `Regex`."},
{"lineNum":"  218","line":"  #"},
{"lineNum":"  219","line":"  # ```"},
{"lineNum":"  220","line":"  # /ab+c/ix.options      # => Regex::Options::IGNORE_CASE | Regex::Options::EXTENDED"},
{"lineNum":"  221","line":"  # /ab+c/ix.options.to_s # => \"IGNORE_CASE, EXTENDED\""},
{"lineNum":"  222","line":"  # ```"},
{"lineNum":"  223","line":"  getter options : Options"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"  # Return the original `String` representation of the `Regex` pattern."},
{"lineNum":"  226","line":"  #"},
{"lineNum":"  227","line":"  # ```"},
{"lineNum":"  228","line":"  # /ab+c/x.source # => \"ab+c\""},
{"lineNum":"  229","line":"  # ```"},
{"lineNum":"  230","line":"  getter source : String"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"  # Creates a new `Regex` out of the given source `String`."},
{"lineNum":"  233","line":"  #"},
{"lineNum":"  234","line":"  # ```"},
{"lineNum":"  235","line":"  # Regex.new(\"^a-z+:\\\\s+\\\\w+\")                   # => /^a-z+:\\s+\\w+/"},
{"lineNum":"  236","line":"  # Regex.new(\"cat\", Regex::Options::IGNORE_CASE) # => /cat/i"},
{"lineNum":"  237","line":"  # options = Regex::Options::IGNORE_CASE | Regex::Options::EXTENDED"},
{"lineNum":"  238","line":"  # Regex.new(\"dog\", options) # => /dog/ix"},
{"lineNum":"  239","line":"  # ```"},
{"lineNum":"  240","line":"  def initialize(source : String, @options : Options = Options::None)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  241","line":"    # PCRE\'s pattern must have their null characters escaped"},
{"lineNum":"  242","line":"    source = source.gsub(\'\\u{0}\', \"\\\\0\")","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  243","line":"    @source = source","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"    @re = LibPCRE.compile(@source, (options | Options::UTF_8 | Options::NO_UTF8_CHECK | Options::DUPNAMES), out errptr, out erroffset, nil)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  246","line":"    raise ArgumentError.new(\"#{String.new(errptr)} at #{erroffset}\") if @re.null?","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  247","line":"    @extra = LibPCRE.study(@re, 0, out studyerrptr)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  248","line":"    raise ArgumentError.new(\"#{String.new(studyerrptr)}\") if @extra.null? && studyerrptr","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  249","line":"    LibPCRE.full_info(@re, nil, LibPCRE::INFO_CAPTURECOUNT, out @captures)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  250","line":"  end"},
{"lineNum":"  251","line":""},
{"lineNum":"  252","line":"  # Determines Regex\'s source validity. If it is, `nil` is returned."},
{"lineNum":"  253","line":"  # If it\'s not, a `String` containing the error message is returned."},
{"lineNum":"  254","line":"  #"},
{"lineNum":"  255","line":"  # ```"},
{"lineNum":"  256","line":"  # Regex.error?(\"(foo|bar)\") # => nil"},
{"lineNum":"  257","line":"  # Regex.error?(\"(foo|bar\")  # => \"missing ) at 8\""},
{"lineNum":"  258","line":"  # ```"},
{"lineNum":"  259","line":"  def self.error?(source)"},
{"lineNum":"  260","line":"    re = LibPCRE.compile(source, (Options::UTF_8 | Options::NO_UTF8_CHECK | Options::DUPNAMES), out errptr, out erroffset, nil)"},
{"lineNum":"  261","line":"    if re"},
{"lineNum":"  262","line":"      nil"},
{"lineNum":"  263","line":"    else"},
{"lineNum":"  264","line":"      \"#{String.new(errptr)} at #{erroffset}\""},
{"lineNum":"  265","line":"    end"},
{"lineNum":"  266","line":"  end"},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"  # Returns a `String` constructed by escaping any metacharacters in *str*."},
{"lineNum":"  269","line":"  #"},
{"lineNum":"  270","line":"  # ```"},
{"lineNum":"  271","line":"  # string = Regex.escape(\"\\*?{}.\") # => \"\\\\*\\\\?\\\\{\\\\}\\\\.\""},
{"lineNum":"  272","line":"  # /#{string}/                     # => /\\*\\?\\{\\}\\./"},
{"lineNum":"  273","line":"  # ```"},
{"lineNum":"  274","line":"  def self.escape(str) : String"},
{"lineNum":"  275","line":"    String.build do |result|"},
{"lineNum":"  276","line":"      str.each_byte do |byte|"},
{"lineNum":"  277","line":"        case byte.unsafe_chr"},
{"lineNum":"  278","line":"        when \' \', \'.\', \'\\\\\', \'+\', \'*\', \'?\', \'[\',"},
{"lineNum":"  279","line":"             \'^\', \']\', \'$\', \'(\', \')\', \'{\', \'}\',"},
{"lineNum":"  280","line":"             \'=\', \'!\', \'<\', \'>\', \'|\', \':\', \'-\'"},
{"lineNum":"  281","line":"          result << \'\\\\\'"},
{"lineNum":"  282","line":"          result.write_byte byte"},
{"lineNum":"  283","line":"        else"},
{"lineNum":"  284","line":"          result.write_byte byte","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  285","line":"        end"},
{"lineNum":"  286","line":"      end"},
{"lineNum":"  287","line":"    end"},
{"lineNum":"  288","line":"  end"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"  # Union. Returns a `Regex` that matches any of *patterns*."},
{"lineNum":"  291","line":"  #"},
{"lineNum":"  292","line":"  # All capture groups in the patterns after the first one will have their"},
{"lineNum":"  293","line":"  # indexes offset."},
{"lineNum":"  294","line":"  #"},
{"lineNum":"  295","line":"  # ```"},
{"lineNum":"  296","line":"  # re = Regex.union([/skiing/i, \"sledding\"])"},
{"lineNum":"  297","line":"  # re.match(\"Skiing\")   # => #<Regex::MatchData \"Skiing\">"},
{"lineNum":"  298","line":"  # re.match(\"sledding\") # => #<Regex::MatchData \"sledding\">"},
{"lineNum":"  299","line":"  # re = Regex.union({/skiing/i, \"sledding\"})"},
{"lineNum":"  300","line":"  # re.match(\"Skiing\")   # => #<Regex::MatchData \"Skiing\">"},
{"lineNum":"  301","line":"  # re.match(\"sledding\") # => #<Regex::MatchData \"sledding\">"},
{"lineNum":"  302","line":"  # ```"},
{"lineNum":"  303","line":"  def self.union(patterns : Enumerable(Regex | String)) : self"},
{"lineNum":"  304","line":"    new patterns.map { |pattern| union_part pattern }.join(\"|\")"},
{"lineNum":"  305","line":"  end"},
{"lineNum":"  306","line":""},
{"lineNum":"  307","line":"  # Union. Returns a `Regex` that matches any of *patterns*."},
{"lineNum":"  308","line":"  #"},
{"lineNum":"  309","line":"  # All capture groups in the patterns after the first one will have their"},
{"lineNum":"  310","line":"  # indexes offset."},
{"lineNum":"  311","line":"  #"},
{"lineNum":"  312","line":"  # ```"},
{"lineNum":"  313","line":"  # re = Regex.union(/skiing/i, \"sledding\")"},
{"lineNum":"  314","line":"  # re.match(\"Skiing\")   # => #<Regex::MatchData \"Skiing\">"},
{"lineNum":"  315","line":"  # re.match(\"sledding\") # => #<Regex::MatchData \"sledding\">"},
{"lineNum":"  316","line":"  # ```"},
{"lineNum":"  317","line":"  def self.union(*patterns : Regex | String) : self"},
{"lineNum":"  318","line":"    union patterns"},
{"lineNum":"  319","line":"  end"},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"  private def self.union_part(pattern : Regex)"},
{"lineNum":"  322","line":"    pattern.to_s"},
{"lineNum":"  323","line":"  end"},
{"lineNum":"  324","line":""},
{"lineNum":"  325","line":"  private def self.union_part(pattern : String)"},
{"lineNum":"  326","line":"    escape pattern"},
{"lineNum":"  327","line":"  end"},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"  # Union. Returns a `Regex` that matches either of the operands."},
{"lineNum":"  330","line":"  #"},
{"lineNum":"  331","line":"  # All capture groups in the second operand will have their indexes"},
{"lineNum":"  332","line":"  # offset."},
{"lineNum":"  333","line":"  #"},
{"lineNum":"  334","line":"  # ```"},
{"lineNum":"  335","line":"  # re = /skiing/i + /sledding/"},
{"lineNum":"  336","line":"  # re.match(\"Skiing\")   # => #<Regex::MatchData \"Skiing\">"},
{"lineNum":"  337","line":"  # re.match(\"sledding\") # => #<Regex::MatchData \"sledding\">"},
{"lineNum":"  338","line":"  # ```"},
{"lineNum":"  339","line":"  def +(other)"},
{"lineNum":"  340","line":"    Regex.union(self, other)"},
{"lineNum":"  341","line":"  end"},
{"lineNum":"  342","line":""},
{"lineNum":"  343","line":"  # Equality. Two regexes are equal if their sources and options are the same."},
{"lineNum":"  344","line":"  #"},
{"lineNum":"  345","line":"  # ```"},
{"lineNum":"  346","line":"  # /abc/ == /abc/i  # => false"},
{"lineNum":"  347","line":"  # /abc/i == /ABC/i # => false"},
{"lineNum":"  348","line":"  # /abc/i == /abc/i # => true"},
{"lineNum":"  349","line":"  # ```"},
{"lineNum":"  350","line":"  def ==(other : Regex)"},
{"lineNum":"  351","line":"    source == other.source && options == other.options"},
{"lineNum":"  352","line":"  end"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":"  # Case equality. This is equivalent to `#match` or `#=~` but only returns"},
{"lineNum":"  355","line":"  # `true` or `false`. Used in `case` expressions. The special variable"},
{"lineNum":"  356","line":"  # `$~` will contain a `Regex::MatchData` if there was a match, `nil` otherwise."},
{"lineNum":"  357","line":"  #"},
{"lineNum":"  358","line":"  # ```"},
{"lineNum":"  359","line":"  # a = \"HELLO\""},
{"lineNum":"  360","line":"  # b = case a"},
{"lineNum":"  361","line":"  #     when /^[a-z]*$/"},
{"lineNum":"  362","line":"  #       \"Lower case\""},
{"lineNum":"  363","line":"  #     when /^[A-Z]*$/"},
{"lineNum":"  364","line":"  #       \"Upper case\""},
{"lineNum":"  365","line":"  #     else"},
{"lineNum":"  366","line":"  #       \"Mixed case\""},
{"lineNum":"  367","line":"  #     end"},
{"lineNum":"  368","line":"  # b # => \"Upper case\""},
{"lineNum":"  369","line":"  # ```"},
{"lineNum":"  370","line":"  def ===(other : String)"},
{"lineNum":"  371","line":"    match = match(other)","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  372","line":"    $~ = match","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  373","line":"    !match.nil?"},
{"lineNum":"  374","line":"  end"},
{"lineNum":"  375","line":""},
{"lineNum":"  376","line":"  # Match. Matches a regular expression against *other* and returns"},
{"lineNum":"  377","line":"  # the starting position of the match if *other* is a matching `String`,"},
{"lineNum":"  378","line":"  # otherwise `nil`. `$~` will contain a `Regex::MatchData` if there was a match,"},
{"lineNum":"  379","line":"  # `nil` otherwise."},
{"lineNum":"  380","line":"  #"},
{"lineNum":"  381","line":"  # ```"},
{"lineNum":"  382","line":"  # /at/ =~ \"input data\" # => 7"},
{"lineNum":"  383","line":"  # /ax/ =~ \"input data\" # => nil"},
{"lineNum":"  384","line":"  # ```"},
{"lineNum":"  385","line":"  def =~(other : String)"},
{"lineNum":"  386","line":"    match = self.match(other)"},
{"lineNum":"  387","line":"    $~ = match"},
{"lineNum":"  388","line":"    match.try &.begin(0)"},
{"lineNum":"  389","line":"  end"},
{"lineNum":"  390","line":""},
{"lineNum":"  391","line":"  # Match. When the argument is not a `String`, always returns `nil`."},
{"lineNum":"  392","line":"  #"},
{"lineNum":"  393","line":"  # ```"},
{"lineNum":"  394","line":"  # /at/ =~ \"input data\" # => 7"},
{"lineNum":"  395","line":"  # /ax/ =~ \"input data\" # => nil"},
{"lineNum":"  396","line":"  # ```"},
{"lineNum":"  397","line":"  def =~(other)"},
{"lineNum":"  398","line":"    nil"},
{"lineNum":"  399","line":"  end"},
{"lineNum":"  400","line":""},
{"lineNum":"  401","line":"  # Convert to `String` in literal format. Returns the source as a `String` in"},
{"lineNum":"  402","line":"  # Regex literal format, delimited in forward slashes (`/`), with any"},
{"lineNum":"  403","line":"  # optional flags included."},
{"lineNum":"  404","line":"  #"},
{"lineNum":"  405","line":"  # ```"},
{"lineNum":"  406","line":"  # /ab+c/ix.inspect # => \"/ab+c/ix\""},
{"lineNum":"  407","line":"  # ```"},
{"lineNum":"  408","line":"  def inspect(io : IO)"},
{"lineNum":"  409","line":"    io << \"/\""},
{"lineNum":"  410","line":"    append_source(io)"},
{"lineNum":"  411","line":"    io << \"/\""},
{"lineNum":"  412","line":"    io << \"i\" if options.ignore_case?"},
{"lineNum":"  413","line":"    io << \"m\" if options.multiline?"},
{"lineNum":"  414","line":"    io << \"x\" if options.extended?"},
{"lineNum":"  415","line":"  end"},
{"lineNum":"  416","line":""},
{"lineNum":"  417","line":"  # Match at character index. Matches a regular expression against `String`"},
{"lineNum":"  418","line":"  # *str*. Starts at the character index given by *pos* if given, otherwise at"},
{"lineNum":"  419","line":"  # the start of *str*. Returns a `Regex::MatchData` if *str* matched, otherwise"},
{"lineNum":"  420","line":"  # `nil`. `$~` will contain the same value that was returned."},
{"lineNum":"  421","line":"  #"},
{"lineNum":"  422","line":"  # ```"},
{"lineNum":"  423","line":"  # /(.)(.)(.)/.match(\"abc\").try &.[2]   # => \"b\""},
{"lineNum":"  424","line":"  # /(.)(.)/.match(\"abc\", 1).try &.[2]   # => \"c\""},
{"lineNum":"  425","line":"  # /(.)(.)/.match(\"クリスタル\", 3).try &.[2] # => \"ル\""},
{"lineNum":"  426","line":"  # ```"},
{"lineNum":"  427","line":"  def match(str, pos = 0, options = Regex::Options::None) : MatchData?","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  428","line":"    if byte_index = str.char_index_to_byte_index(pos)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  429","line":"      match = match_at_byte_index(str, byte_index, options)"},
{"lineNum":"  430","line":"    else"},
{"lineNum":"  431","line":"      match = nil"},
{"lineNum":"  432","line":"    end"},
{"lineNum":"  433","line":""},
{"lineNum":"  434","line":"    $~ = match","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  435","line":"  end"},
{"lineNum":"  436","line":""},
{"lineNum":"  437","line":"  # Match at byte index. Matches a regular expression against `String`"},
{"lineNum":"  438","line":"  # *str*. Starts at the byte index given by *pos* if given, otherwise at"},
{"lineNum":"  439","line":"  # the start of *str*. Returns a `Regex::MatchData` if *str* matched, otherwise"},
{"lineNum":"  440","line":"  # `nil`. `$~` will contain the same value that was returned."},
{"lineNum":"  441","line":"  #"},
{"lineNum":"  442","line":"  # ```"},
{"lineNum":"  443","line":"  # /(.)(.)(.)/.match_at_byte_index(\"abc\").try &.[2]   # => \"b\""},
{"lineNum":"  444","line":"  # /(.)(.)/.match_at_byte_index(\"abc\", 1).try &.[2]   # => \"c\""},
{"lineNum":"  445","line":"  # /(.)(.)/.match_at_byte_index(\"クリスタル\", 3).try &.[2] # => \"ス\""},
{"lineNum":"  446","line":"  # ```"},
{"lineNum":"  447","line":"  def match_at_byte_index(str, byte_index = 0, options = Regex::Options::None) : MatchData?","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  448","line":"    return ($~ = nil) if byte_index > str.bytesize","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  449","line":""},
{"lineNum":"  450","line":"    ovector_size = (@captures + 1) * 3"},
{"lineNum":"  451","line":"    ovector = Pointer(Int32).malloc(ovector_size)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  452","line":"    ret = LibPCRE.exec(@re, @extra, str, str.bytesize, byte_index, (options | Options::NO_UTF8_CHECK), ovector, ovector_size)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  453","line":"    if ret > 0","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  454","line":"      match = MatchData.new(self, @re, str, byte_index, ovector, @captures)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  455","line":"    else"},
{"lineNum":"  456","line":"      match = nil"},
{"lineNum":"  457","line":"    end"},
{"lineNum":"  458","line":""},
{"lineNum":"  459","line":"    $~ = match","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  460","line":"  end"},
{"lineNum":"  461","line":""},
{"lineNum":"  462","line":"  # Returns a `Hash` where the values are the names of capture groups and the"},
{"lineNum":"  463","line":"  # keys are their indexes. Non-named capture groups will not have entries in"},
{"lineNum":"  464","line":"  # the `Hash`. Capture groups are indexed starting from `1`."},
{"lineNum":"  465","line":"  #"},
{"lineNum":"  466","line":"  # ```"},
{"lineNum":"  467","line":"  # /(.)/.name_table                         # => {}"},
{"lineNum":"  468","line":"  # /(?<foo>.)/.name_table                   # => {1 => \"foo\"}"},
{"lineNum":"  469","line":"  # /(?<foo>.)(?<bar>.)/.name_table          # => {2 => \"bar\", 1 => \"foo\"}"},
{"lineNum":"  470","line":"  # /(.)(?<foo>.)(.)(?<bar>.)(.)/.name_table # => {4 => \"bar\", 2 => \"foo\"}"},
{"lineNum":"  471","line":"  # ```"},
{"lineNum":"  472","line":"  def name_table : Hash(UInt16, String)"},
{"lineNum":"  473","line":"    LibPCRE.full_info(@re, @extra, LibPCRE::INFO_NAMECOUNT, out name_count)"},
{"lineNum":"  474","line":"    LibPCRE.full_info(@re, @extra, LibPCRE::INFO_NAMEENTRYSIZE, out name_entry_size)"},
{"lineNum":"  475","line":"    table_pointer = Pointer(UInt8).null"},
{"lineNum":"  476","line":"    LibPCRE.full_info(@re, @extra, LibPCRE::INFO_NAMETABLE, pointerof(table_pointer).as(Pointer(Int32)))"},
{"lineNum":"  477","line":"    name_table = table_pointer.to_slice(name_entry_size*name_count)"},
{"lineNum":"  478","line":""},
{"lineNum":"  479","line":"    lookup = Hash(UInt16, String).new"},
{"lineNum":"  480","line":""},
{"lineNum":"  481","line":"    name_count.times do |i|"},
{"lineNum":"  482","line":"      capture_offset = i * name_entry_size"},
{"lineNum":"  483","line":"      capture_number = (name_table[capture_offset].to_u16 << 8) | name_table[capture_offset + 1].to_u16"},
{"lineNum":"  484","line":""},
{"lineNum":"  485","line":"      name_offset = capture_offset + 2"},
{"lineNum":"  486","line":"      name = String.new((name_table + name_offset).pointer(name_entry_size - 3))"},
{"lineNum":"  487","line":""},
{"lineNum":"  488","line":"      lookup[capture_number] = name"},
{"lineNum":"  489","line":"    end"},
{"lineNum":"  490","line":""},
{"lineNum":"  491","line":"    lookup"},
{"lineNum":"  492","line":"  end"},
{"lineNum":"  493","line":""},
{"lineNum":"  494","line":"  # Convert to `String` in subpattern format. Produces a `String` which can be"},
{"lineNum":"  495","line":"  # embedded in another `Regex` via interpolation, where it will be interpreted"},
{"lineNum":"  496","line":"  # as a non-capturing subexpression in another regular expression."},
{"lineNum":"  497","line":"  #"},
{"lineNum":"  498","line":"  # ```"},
{"lineNum":"  499","line":"  # re = /A*/i                 # => /A*/i"},
{"lineNum":"  500","line":"  # re.to_s                    # => \"(?i-msx:A*)\""},
{"lineNum":"  501","line":"  # \"Crystal\".match(/t#{re}l/) # => #<Regex::MatchData \"tal\">"},
{"lineNum":"  502","line":"  # re = /A*/                  # => \"(?-imsx:A*)\""},
{"lineNum":"  503","line":"  # \"Crystal\".match(/t#{re}l/) # => nil"},
{"lineNum":"  504","line":"  # ```"},
{"lineNum":"  505","line":"  def to_s(io : IO)"},
{"lineNum":"  506","line":"    io << \"(?\""},
{"lineNum":"  507","line":"    io << \"i\" if options.ignore_case?"},
{"lineNum":"  508","line":"    io << \"ms\" if options.multiline?"},
{"lineNum":"  509","line":"    io << \"x\" if options.extended?"},
{"lineNum":"  510","line":""},
{"lineNum":"  511","line":"    io << \"-\""},
{"lineNum":"  512","line":"    io << \"i\" unless options.ignore_case?"},
{"lineNum":"  513","line":"    io << \"ms\" unless options.multiline?"},
{"lineNum":"  514","line":"    io << \"x\" unless options.extended?"},
{"lineNum":"  515","line":""},
{"lineNum":"  516","line":"    io << \":\""},
{"lineNum":"  517","line":"    append_source(io)"},
{"lineNum":"  518","line":"    io << \")\""},
{"lineNum":"  519","line":"  end"},
{"lineNum":"  520","line":""},
{"lineNum":"  521","line":"  private def append_source(io)"},
{"lineNum":"  522","line":"    source.each_char do |char|"},
{"lineNum":"  523","line":"      if char == \'/\'"},
{"lineNum":"  524","line":"        io << \"\\\\/\""},
{"lineNum":"  525","line":"      else"},
{"lineNum":"  526","line":"        io << char"},
{"lineNum":"  527","line":"      end"},
{"lineNum":"  528","line":"    end"},
{"lineNum":"  529","line":"  end"},
{"lineNum":"  530","line":""},
{"lineNum":"  531","line":"  def dup"},
{"lineNum":"  532","line":"    self"},
{"lineNum":"  533","line":"  end"},
{"lineNum":"  534","line":""},
{"lineNum":"  535","line":"  def clone"},
{"lineNum":"  536","line":"    self"},
{"lineNum":"  537","line":"  end"},
{"lineNum":"  538","line":"end"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "roman_spec", "date" : "2018-03-12 14:24:04", "instrumented" : 23, "covered" : 0,};
var merged_data = [];
