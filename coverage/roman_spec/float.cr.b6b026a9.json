var data = {lines:[
{"lineNum":"    1","line":"require \"c/stdio\""},
{"lineNum":"    2","line":"require \"c/string\""},
{"lineNum":"    3","line":"require \"./float/printer\""},
{"lineNum":"    4","line":""},
{"lineNum":"    5","line":"# Float is the base type of all floating point numbers."},
{"lineNum":"    6","line":"#"},
{"lineNum":"    7","line":"# There are two floating point types, `Float32` and `Float64`,"},
{"lineNum":"    8","line":"# which correspond to the [binary32](http://en.wikipedia.org/wiki/Single_precision_floating-point_format)"},
{"lineNum":"    9","line":"# and [binary64](http://en.wikipedia.org/wiki/Double_precision_floating-point_format)"},
{"lineNum":"   10","line":"# types defined by IEEE."},
{"lineNum":"   11","line":"#"},
{"lineNum":"   12","line":"# A floating point literal is an optional `+` or `-` sign, followed by"},
{"lineNum":"   13","line":"# a sequence of numbers or underscores, followed by a dot,"},
{"lineNum":"   14","line":"# followed by numbers or underscores, followed by an optional exponent suffix,"},
{"lineNum":"   15","line":"# followed by an optional type suffix. If no suffix is present, the literal\'s type is `Float64`."},
{"lineNum":"   16","line":"#"},
{"lineNum":"   17","line":"# ```"},
{"lineNum":"   18","line":"# 1.0     # Float64"},
{"lineNum":"   19","line":"# 1.0_f32 # Float32"},
{"lineNum":"   20","line":"# 1_f32   # Float32"},
{"lineNum":"   21","line":"#"},
{"lineNum":"   22","line":"# 1e10   # Float64"},
{"lineNum":"   23","line":"# 1.5e10 # Float64"},
{"lineNum":"   24","line":"# 1.5e-7 # Float64"},
{"lineNum":"   25","line":"#"},
{"lineNum":"   26","line":"# +1.3 # Float64"},
{"lineNum":"   27","line":"# -0.5 # Float64"},
{"lineNum":"   28","line":"# ```","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   29","line":"#"},
{"lineNum":"   30","line":"# The underscore `_` before the suffix is optional."},
{"lineNum":"   31","line":"#"},
{"lineNum":"   32","line":"# Underscores can be used to make some numbers more readable:"},
{"lineNum":"   33","line":"#"},
{"lineNum":"   34","line":"# ```"},
{"lineNum":"   35","line":"# 1_000_000.111_111 # better than 1000000.111111"},
{"lineNum":"   36","line":"# ```"},
{"lineNum":"   37","line":"struct Float"},
{"lineNum":"   38","line":"  alias Primitive = Float32 | Float64"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"  def -"},
{"lineNum":"   41","line":"    self.class.zero - self","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   42","line":"  end"},
{"lineNum":"   43","line":""},
{"lineNum":"   44","line":"  def %(other)"},
{"lineNum":"   45","line":"    modulo(other)"},
{"lineNum":"   46","line":"  end"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"  def nan?"},
{"lineNum":"   49","line":"    !(self == self)"},
{"lineNum":"   50","line":"  end"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"  def infinite?"},
{"lineNum":"   53","line":"    if nan? || self == 0 || self != 2 * self"},
{"lineNum":"   54","line":"      nil"},
{"lineNum":"   55","line":"    else"},
{"lineNum":"   56","line":"      self > 0 ? 1 : -1"},
{"lineNum":"   57","line":"    end"},
{"lineNum":"   58","line":"  end"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"  def finite?"},
{"lineNum":"   61","line":"    !nan? && !infinite?"},
{"lineNum":"   62","line":"  end"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"  def fdiv(other)"},
{"lineNum":"   65","line":"    self / other"},
{"lineNum":"   66","line":"  end"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"  def modulo(other)"},
{"lineNum":"   69","line":"    if other == 0.0"},
{"lineNum":"   70","line":"      raise DivisionByZero.new"},
{"lineNum":"   71","line":"    else"},
{"lineNum":"   72","line":"      self - other * self.fdiv(other).floor"},
{"lineNum":"   73","line":"    end"},
{"lineNum":"   74","line":"  end"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"  def remainder(other)"},
{"lineNum":"   77","line":"    if other == 0.0"},
{"lineNum":"   78","line":"      raise DivisionByZero.new"},
{"lineNum":"   79","line":"    else"},
{"lineNum":"   80","line":"      mod = self % other"},
{"lineNum":"   81","line":"      return self.class.zero if mod == 0.0"},
{"lineNum":"   82","line":"      return mod if self > 0 && other > 0"},
{"lineNum":"   83","line":"      return mod if self < 0 && other < 0"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"      mod - other"},
{"lineNum":"   86","line":"    end"},
{"lineNum":"   87","line":"  end"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"  # See `Object#hash(hasher)`"},
{"lineNum":"   90","line":"  def hash(hasher)"},
{"lineNum":"   91","line":"    hasher.float(self)"},
{"lineNum":"   92","line":"  end"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"  # Writes this float to the given *io* in the given *format*."},
{"lineNum":"   95","line":"  # See also: `IO#write_bytes`."},
{"lineNum":"   96","line":"  def to_io(io : IO, format : IO::ByteFormat)"},
{"lineNum":"   97","line":"    format.encode(self, io)"},
{"lineNum":"   98","line":"  end"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"  # Reads a float from the given *io* in the given *format*."},
{"lineNum":"  101","line":"  # See also: `IO#read_bytes`."},
{"lineNum":"  102","line":"  def self.from_io(io : IO, format : IO::ByteFormat) : self"},
{"lineNum":"  103","line":"    format.decode(self, io)"},
{"lineNum":"  104","line":"  end"},
{"lineNum":"  105","line":"end"},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"struct Float32"},
{"lineNum":"  108","line":"  NAN      = (0_f32 / 0_f32).as Float32"},
{"lineNum":"  109","line":"  INFINITY = (1_f32 / 0_f32).as Float32"},
{"lineNum":"  110","line":"  MIN      = (-INFINITY).as Float32"},
{"lineNum":"  111","line":"  MAX      = INFINITY.as Float32"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"  # Returns a `Float32` by invoking `to_f32` on *value*."},
{"lineNum":"  114","line":"  def self.new(value)"},
{"lineNum":"  115","line":"    value.to_f32"},
{"lineNum":"  116","line":"  end"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"  def ceil"},
{"lineNum":"  119","line":"    LibM.ceil_f32(self)"},
{"lineNum":"  120","line":"  end"},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"  def floor"},
{"lineNum":"  123","line":"    LibM.floor_f32(self)"},
{"lineNum":"  124","line":"  end"},
{"lineNum":"  125","line":""},
{"lineNum":"  126","line":"  def round"},
{"lineNum":"  127","line":"    LibM.round_f32(self)"},
{"lineNum":"  128","line":"  end"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"  def trunc"},
{"lineNum":"  131","line":"    LibM.trunc_f32(self)"},
{"lineNum":"  132","line":"  end"},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"  def **(other : Int32)"},
{"lineNum":"  135","line":"    LibM.powi_f32(self, other)"},
{"lineNum":"  136","line":"  end"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"  def **(other : Float32)"},
{"lineNum":"  139","line":"    LibM.pow_f32(self, other)"},
{"lineNum":"  140","line":"  end"},
{"lineNum":"  141","line":""},
{"lineNum":"  142","line":"  def **(other)"},
{"lineNum":"  143","line":"    self ** other.to_f32"},
{"lineNum":"  144","line":"  end"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"  def to_s"},
{"lineNum":"  147","line":"    String.build(22) do |buffer|"},
{"lineNum":"  148","line":"      Printer.print(self, buffer)"},
{"lineNum":"  149","line":"    end"},
{"lineNum":"  150","line":"  end"},
{"lineNum":"  151","line":""},
{"lineNum":"  152","line":"  def to_s(io : IO)"},
{"lineNum":"  153","line":"    Printer.print(self, io)"},
{"lineNum":"  154","line":"  end"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"  def inspect(io)"},
{"lineNum":"  157","line":"    to_s(io)"},
{"lineNum":"  158","line":"    io << \"_f32\""},
{"lineNum":"  159","line":"  end"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"  def clone"},
{"lineNum":"  162","line":"    self"},
{"lineNum":"  163","line":"  end"},
{"lineNum":"  164","line":"end"},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"struct Float64"},
{"lineNum":"  167","line":"  NAN      = (0_f64 / 0_f64).as Float64"},
{"lineNum":"  168","line":"  INFINITY = (1_f64 / 0_f64).as Float64"},
{"lineNum":"  169","line":"  MIN      = (-INFINITY).as Float64"},
{"lineNum":"  170","line":"  MAX      = INFINITY.as Float64"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"  # Returns a `Float64` by invoking `to_f64` on *value*."},
{"lineNum":"  173","line":"  def Float64.new(value)"},
{"lineNum":"  174","line":"    value.to_f64"},
{"lineNum":"  175","line":"  end"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"  def ceil"},
{"lineNum":"  178","line":"    LibM.ceil_f64(self)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  179","line":"  end"},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"  def floor"},
{"lineNum":"  182","line":"    LibM.floor_f64(self)"},
{"lineNum":"  183","line":"  end"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"  def round"},
{"lineNum":"  186","line":"    LibM.round_f64(self)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  187","line":"  end"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"  def trunc"},
{"lineNum":"  190","line":"    LibM.trunc_f64(self)"},
{"lineNum":"  191","line":"  end"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"  def **(other : Int32)"},
{"lineNum":"  194","line":"    LibM.powi_f64(self, other)"},
{"lineNum":"  195","line":"  end"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"  def **(other : Float64)"},
{"lineNum":"  198","line":"    LibM.pow_f64(self, other)"},
{"lineNum":"  199","line":"  end"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"  def **(other)"},
{"lineNum":"  202","line":"    self ** other.to_f64"},
{"lineNum":"  203","line":"  end"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"  def to_s"},
{"lineNum":"  206","line":"    String.build(22) do |buffer|"},
{"lineNum":"  207","line":"      Printer.print(self, buffer)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  208","line":"    end"},
{"lineNum":"  209","line":"  end"},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"  def to_s(io : IO)"},
{"lineNum":"  212","line":"    Printer.print(self, io)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  213","line":"  end"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"  def clone"},
{"lineNum":"  216","line":"    self"},
{"lineNum":"  217","line":"  end"},
{"lineNum":"  218","line":"end"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "roman_spec", "date" : "2018-03-12 14:57:27", "instrumented" : 6, "covered" : 0,};
var merged_data = [];
