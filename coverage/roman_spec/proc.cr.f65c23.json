var data = {lines:[
{"lineNum":"    1","line":"# A `Proc` represents a function pointer with an optional context (the closure data)."},
{"lineNum":"    2","line":"# It is typically created with a proc literal:"},
{"lineNum":"    3","line":"#"},
{"lineNum":"    4","line":"# ```"},
{"lineNum":"    5","line":"# # A proc without arguments"},
{"lineNum":"    6","line":"# ->{ 1 } # Proc(Int32)"},
{"lineNum":"    7","line":"#"},
{"lineNum":"    8","line":"# # A proc with one argument"},
{"lineNum":"    9","line":"# ->(x : Int32) { x.to_s } # Proc(Int32, String)"},
{"lineNum":"   10","line":"#"},
{"lineNum":"   11","line":"# # A proc with two arguments:"},
{"lineNum":"   12","line":"# ->(x : Int32, y : Int32) { x + y } # Proc(Int32, Int32, Int32)"},
{"lineNum":"   13","line":"# ```"},
{"lineNum":"   14","line":"#"},
{"lineNum":"   15","line":"# The types of the arguments (`T`) are mandatory, except when directly"},
{"lineNum":"   16","line":"# sending a proc literal to a lib fun in C bindings."},
{"lineNum":"   17","line":"#"},
{"lineNum":"   18","line":"# The return type (`R`) is inferred from the proc\'s body."},
{"lineNum":"   19","line":"#"},
{"lineNum":"   20","line":"# A special new method is provided too:"},
{"lineNum":"   21","line":"#"},
{"lineNum":"   22","line":"# ```"},
{"lineNum":"   23","line":"# Proc(Int32, String).new { |x| x.to_s } # Proc(Int32, String)"},
{"lineNum":"   24","line":"# ```"},
{"lineNum":"   25","line":"#"},
{"lineNum":"   26","line":"# This form allows you to specify the return type and to check it"},
{"lineNum":"   27","line":"# against the proc\'s body."},
{"lineNum":"   28","line":"#"},
{"lineNum":"   29","line":"# Another way to create a `Proc` is by capturing a block:"},
{"lineNum":"   30","line":"#"},
{"lineNum":"   31","line":"# ```"},
{"lineNum":"   32","line":"# def capture(&block : Int32 -> Int32)"},
{"lineNum":"   33","line":"#   # block argument is used, so block is turned into a Proc"},
{"lineNum":"   34","line":"#   block"},
{"lineNum":"   35","line":"# end"},
{"lineNum":"   36","line":"#"},
{"lineNum":"   37","line":"# proc = capture { |x| x + 1 } # Proc(Int32, Int32)"},
{"lineNum":"   38","line":"# proc.call(1)                 # => 2"},
{"lineNum":"   39","line":"# ```"},
{"lineNum":"   40","line":"#"},
{"lineNum":"   41","line":"# When capturing blocks, the type of the arguments and return type"},
{"lineNum":"   42","line":"# must be specified in the capturing method block signature."},
{"lineNum":"   43","line":"#"},
{"lineNum":"   44","line":"# ### Passing a Proc to a C function"},
{"lineNum":"   45","line":"#"},
{"lineNum":"   46","line":"# Passing a `Proc` to a C function, for example as a callback, is possible"},
{"lineNum":"   47","line":"# as long as the `Proc` isn\'t a closure. If it is, either a compile-time or"},
{"lineNum":"   48","line":"# runtime error will happen depending on whether the compiler can check this."},
{"lineNum":"   49","line":"# The reason is that a `Proc` is internally represented as two void pointers,"},
{"lineNum":"   50","line":"# one having the function pointer and another the closure data. If just"},
{"lineNum":"   51","line":"# the function pointer is passed, the closure data will be missing at invocation time."},
{"lineNum":"   52","line":"#"},
{"lineNum":"   53","line":"# Most of the time a C function that allows setting a callback also provide"},
{"lineNum":"   54","line":"# an argument for custom data. This custom data is then sent as an argument"},
{"lineNum":"   55","line":"# to the callback. For example, suppose a C function that invokes a callback"},
{"lineNum":"   56","line":"# at every tick, passing that tick:"},
{"lineNum":"   57","line":"#"},
{"lineNum":"   58","line":"# ```"},
{"lineNum":"   59","line":"# lib LibTicker"},
{"lineNum":"   60","line":"#   fun on_tick(callback : (Int32, Void* ->), data : Void*)"},
{"lineNum":"   61","line":"# end"},
{"lineNum":"   62","line":"# ```"},
{"lineNum":"   63","line":"#"},
{"lineNum":"   64","line":"# To properly define a wrapper for this function we must send the `Proc` as the"},
{"lineNum":"   65","line":"# callback data, and then convert that callback data to the `Proc` and finally invoke it."},
{"lineNum":"   66","line":"#"},
{"lineNum":"   67","line":"# ```"},
{"lineNum":"   68","line":"# module Ticker"},
{"lineNum":"   69","line":"#   # The callback for the user doesn\'t have a Void*"},
{"lineNum":"   70","line":"#   @@box : Pointer(Void)?"},
{"lineNum":"   71","line":"#"},
{"lineNum":"   72","line":"#   def self.on_tick(&callback : Int32 ->)"},
{"lineNum":"   73","line":"#     # Since Proc is a {Void*, Void*}, we can\'t turn that into a Void*, so we"},
{"lineNum":"   74","line":"#     # \"box\" it: we allocate memory and store the Proc there"},
{"lineNum":"   75","line":"#     boxed_data = Box.box(callback)"},
{"lineNum":"   76","line":"#"},
{"lineNum":"   77","line":"#     # We must save this in Crystal-land so the GC doesn\'t collect it (*)"},
{"lineNum":"   78","line":"#     @@box = boxed_data"},
{"lineNum":"   79","line":"#"},
{"lineNum":"   80","line":"#     # We pass a callback that doesn\'t form a closure, and pass the boxed_data as"},
{"lineNum":"   81","line":"#     # the callback data"},
{"lineNum":"   82","line":"#     LibTicker.on_tick(->(tick, data) {"},
{"lineNum":"   83","line":"#       # Now we turn data back into the Proc, using Box.unbox"},
{"lineNum":"   84","line":"#       data_as_callback = Box(typeof(callback)).unbox(data)"},
{"lineNum":"   85","line":"#       # And finally invoke the user\'s callback"},
{"lineNum":"   86","line":"#       data_as_callback.call(tick)"},
{"lineNum":"   87","line":"#     }, boxed_data)"},
{"lineNum":"   88","line":"#   end"},
{"lineNum":"   89","line":"# end"},
{"lineNum":"   90","line":"#"},
{"lineNum":"   91","line":"# Ticker.on_tick do |tick|"},
{"lineNum":"   92","line":"#   puts tick"},
{"lineNum":"   93","line":"# end"},
{"lineNum":"   94","line":"# ```"},
{"lineNum":"   95","line":"#"},
{"lineNum":"   96","line":"# Note that we save the box in `@@box`. The reason is that if we don\'t do it,"},
{"lineNum":"   97","line":"# and our code doesn\'t reference it anymore, the GC will collect it."},
{"lineNum":"   98","line":"# The C library will of course store the callback, but Crystal\'s GC has"},
{"lineNum":"   99","line":"# no way of knowing that."},
{"lineNum":"  100","line":"struct Proc"},
{"lineNum":"  101","line":"  def self.new(pointer : Void*, closure_data : Void*)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  102","line":"    func = {pointer, closure_data}","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  103","line":"    ptr = pointerof(func).as(self*)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  104","line":"    ptr.value"},
{"lineNum":"  105","line":"  end"},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"  # Returns a new `Proc` that has its first arguments fixed to"},
{"lineNum":"  108","line":"  # the values given by *args*."},
{"lineNum":"  109","line":"  #"},
{"lineNum":"  110","line":"  # See [Wikipedia, Partial application](https://en.wikipedia.org/wiki/Partial_application)"},
{"lineNum":"  111","line":"  #"},
{"lineNum":"  112","line":"  # ```"},
{"lineNum":"  113","line":"  # add = ->(x : Int32, y : Int32) { x + y }"},
{"lineNum":"  114","line":"  # add.call(1, 2) # => 3"},
{"lineNum":"  115","line":"  #"},
{"lineNum":"  116","line":"  # add_one = add.partial(1)"},
{"lineNum":"  117","line":"  # add_one.call(2)  # => 3"},
{"lineNum":"  118","line":"  # add_one.call(10) # => 11"},
{"lineNum":"  119","line":"  #"},
{"lineNum":"  120","line":"  # add_one_and_two = add_one.partial(2)"},
{"lineNum":"  121","line":"  # add_one_and_two.call # => 3"},
{"lineNum":"  122","line":"  # ```"},
{"lineNum":"  123","line":"  def partial(*args : *U) forall U"},
{"lineNum":"  124","line":"    {% begin %}"},
{"lineNum":"  125","line":"      {% remaining = (T.size - U.size) %}"},
{"lineNum":"  126","line":"      ->("},
{"lineNum":"  127","line":"          {% for i in 0...remaining %}"},
{"lineNum":"  128","line":"            arg{{i}} : {{T[i + U.size]}},"},
{"lineNum":"  129","line":"          {% end %}"},
{"lineNum":"  130","line":"        ) {"},
{"lineNum":"  131","line":"        call("},
{"lineNum":"  132","line":"          *args,"},
{"lineNum":"  133","line":"          {% for i in 0...remaining %}"},
{"lineNum":"  134","line":"            arg{{i}},"},
{"lineNum":"  135","line":"          {% end %}"},
{"lineNum":"  136","line":"        )"},
{"lineNum":"  137","line":"      }"},
{"lineNum":"  138","line":"    {% end %}"},
{"lineNum":"  139","line":"  end"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"  # Returns the number of arguments of this `Proc`."},
{"lineNum":"  142","line":"  #"},
{"lineNum":"  143","line":"  # ```"},
{"lineNum":"  144","line":"  # add = ->(x : Int32, y : Int32) { x + y }"},
{"lineNum":"  145","line":"  # add.arity # => 2"},
{"lineNum":"  146","line":"  #"},
{"lineNum":"  147","line":"  # neg = ->(x : Int32) { -x }"},
{"lineNum":"  148","line":"  # neg.arity # => 1"},
{"lineNum":"  149","line":"  # ```"},
{"lineNum":"  150","line":"  def arity"},
{"lineNum":"  151","line":"    {{T.size}}"},
{"lineNum":"  152","line":"  end"},
{"lineNum":"  153","line":""},
{"lineNum":"  154","line":"  def pointer","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  155","line":"    internal_representation[0]","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  156","line":"  end"},
{"lineNum":"  157","line":""},
{"lineNum":"  158","line":"  def closure_data"},
{"lineNum":"  159","line":"    internal_representation[1]"},
{"lineNum":"  160","line":"  end"},
{"lineNum":"  161","line":""},
{"lineNum":"  162","line":"  def closure?"},
{"lineNum":"  163","line":"    !closure_data.null?"},
{"lineNum":"  164","line":"  end"},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"  private def internal_representation","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  167","line":"    func = self","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  168","line":"    ptr = pointerof(func).as({Void*, Void*}*)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  169","line":"    ptr.value"},
{"lineNum":"  170","line":"  end"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"  def ==(other : self)"},
{"lineNum":"  173","line":"    pointer == other.pointer && closure_data == other.closure_data"},
{"lineNum":"  174","line":"  end"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"  def ===(other : self)"},
{"lineNum":"  177","line":"    self == other"},
{"lineNum":"  178","line":"  end"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":"  def ===(other)"},
{"lineNum":"  181","line":"    call(other)"},
{"lineNum":"  182","line":"  end"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"  # See `Object#hash(hasher)`"},
{"lineNum":"  185","line":"  def hash(hasher)"},
{"lineNum":"  186","line":"    internal_representation.hash(hasher)"},
{"lineNum":"  187","line":"  end"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"  def clone"},
{"lineNum":"  190","line":"    self"},
{"lineNum":"  191","line":"  end"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"  def to_s(io)"},
{"lineNum":"  194","line":"    io << \"#<\""},
{"lineNum":"  195","line":"    io << {{@type.name.stringify}}"},
{"lineNum":"  196","line":"    io << \":0x\""},
{"lineNum":"  197","line":"    pointer.address.to_s(16, io)"},
{"lineNum":"  198","line":"    if closure?"},
{"lineNum":"  199","line":"      io << \":closure\""},
{"lineNum":"  200","line":"    end"},
{"lineNum":"  201","line":"    io << \">\""},
{"lineNum":"  202","line":"    nil"},
{"lineNum":"  203","line":"  end"},
{"lineNum":"  204","line":"end"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "roman_spec", "date" : "2018-03-12 14:20:30", "instrumented" : 8, "covered" : 0,};
var merged_data = [];
