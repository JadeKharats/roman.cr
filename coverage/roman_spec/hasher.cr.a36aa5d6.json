var data = {lines:[
{"lineNum":"    1","line":"require \"random/secure\""},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"# :nodoc:"},
{"lineNum":"    4","line":"struct Crystal::Hasher"},
{"lineNum":"    5","line":"  # Implementation of a Hasher to compute a fast and safe hash"},
{"lineNum":"    6","line":"  # value for primitive and basic Crystal objects. All other"},
{"lineNum":"    7","line":"  # hashes are computed based on these."},
{"lineNum":"    8","line":"  #"},
{"lineNum":"    9","line":"  # The algorithm bases on https://github.com/funny-falcon/funny_hash"},
{"lineNum":"   10","line":"  #"},
{"lineNum":"   11","line":"  # It is two multiply-rotate 64bit hash functions, combined"},
{"lineNum":"   12","line":"  # within finalizer."},
{"lineNum":"   13","line":"  #"},
{"lineNum":"   14","line":"  # Both hash functions combines previous state with a block value"},
{"lineNum":"   15","line":"  # before multiplication. One function multiplies new state"},
{"lineNum":"   16","line":"  # as is (and then rotates state), other multiplies new state"},
{"lineNum":"   17","line":"  # already rotated by 32 bits."},
{"lineNum":"   18","line":"  #"},
{"lineNum":"   19","line":"  # This way algorithm ensures that every block bit affects at"},
{"lineNum":"   20","line":"  # least 1 bit of every state, and certainly many bits of some"},
{"lineNum":"   21","line":"  # state. So effect of this bit could not be easily canceled"},
{"lineNum":"   22","line":"  # with following blocks. (Cause next blocks have to cancel"},
{"lineNum":"   23","line":"  # bits on non-intersecting positions in both states)."},
{"lineNum":"   24","line":"  # Rotation by 32bit with multiplication also provides good"},
{"lineNum":"   25","line":"  # inter-block avalanche."},
{"lineNum":"   26","line":"  #"},
{"lineNum":"   27","line":"  # Finalizer performs murmur-like finalization on both functions,"},
{"lineNum":"   28","line":"  # and then combines them with addition. It greatly reduce"},
{"lineNum":"   29","line":"  # possibility of state deduction."},
{"lineNum":"   30","line":"  #"},
{"lineNum":"   31","line":"  # Note, it provides good protection from HashDos if and only if:"},
{"lineNum":"   32","line":"  # - seed is securely random and not exposed to attacker,"},
{"lineNum":"   33","line":"  # - hash result is also not exposed to attacker in a way other"},
{"lineNum":"   34","line":"  #   than effect of using it in Hash implementation."},
{"lineNum":"   35","line":"  # Do not output calculated hash value to user\'s console/form/"},
{"lineNum":"   36","line":"  # html/api response, etc. Use some from digest package instead."},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"  # Based on https://github.com/python/cpython/blob/f051e43/Python/pyhash.c#L34"},
{"lineNum":"   39","line":"  #"},
{"lineNum":"   40","line":"  # For numeric types, the hash of a number x is based on the reduction"},
{"lineNum":"   41","line":"  # of x modulo the Mersen Prime P = 2**HASH_BITS - 1.  It\'s designed"},
{"lineNum":"   42","line":"  # so that hash(x) == hash(y) whenever x and y are numerically equal,"},
{"lineNum":"   43","line":"  # even if x and y have different types."},
{"lineNum":"   44","line":"  # A quick summary of the hashing strategy:"},
{"lineNum":"   45","line":"  # (1) First define the \'reduction of x modulo P\' for any rational"},
{"lineNum":"   46","line":"  # number x; this is a standard extension of the usual notion of"},
{"lineNum":"   47","line":"  # reduction modulo P for integers.  If x == p/q (written in lowest"},
{"lineNum":"   48","line":"  # terms), the reduction is interpreted as the reduction of p times"},
{"lineNum":"   49","line":"  # the inverse of the reduction of q, all modulo P; if q is exactly"},
{"lineNum":"   50","line":"  # divisible by P then define the reduction to be infinity.  So we\'ve"},
{"lineNum":"   51","line":"  # got a well-defined map"},
{"lineNum":"   52","line":"  #   reduce : { rational numbers } -> { 0, 1, 2, ..., P-1, infinity }."},
{"lineNum":"   53","line":"  # (2) Now for a rational number x, define hash(x) by:"},
{"lineNum":"   54","line":"  #   reduce(x)   if x >= 0"},
{"lineNum":"   55","line":"  #   -reduce(-x) if x < 0"},
{"lineNum":"   56","line":"  # If the result of the reduction is infinity (this is impossible for"},
{"lineNum":"   57","line":"  # integers, floats and Decimals) then use the predefined hash value"},
{"lineNum":"   58","line":"  # HASH_INF_PLUS for x >= 0, or HASH_INF_MINUS for x < 0, instead."},
{"lineNum":"   59","line":"  # HASH_INF_PLUS, HASH_INF_MINUS and HASH_NAN are also used for the"},
{"lineNum":"   60","line":"  # hashes of float and Decimal infinities and nans."},
{"lineNum":"   61","line":"  # A selling point for the above strategy is that it makes it possible"},
{"lineNum":"   62","line":"  # to compute hashes of decimal and binary floating-point numbers"},
{"lineNum":"   63","line":"  # efficiently, even if the exponent of the binary or decimal number"},
{"lineNum":"   64","line":"  # is large.  The key point is that"},
{"lineNum":"   65","line":"  #   reduce(x * y) == reduce(x) * reduce(y) (modulo HASH_MODULUS)"},
{"lineNum":"   66","line":"  # provided that {reduce(x), reduce(y)} != {0, infinity}.  The reduction of a"},
{"lineNum":"   67","line":"  # binary or decimal float is never infinity, since the denominator is a power"},
{"lineNum":"   68","line":"  # of 2 (for binary) or a divisor of a power of 10 (for decimal).  So we have,"},
{"lineNum":"   69","line":"  # for nonnegative x,"},
{"lineNum":"   70","line":"  #   reduce(x * 2**e) == reduce(x) * reduce(2**e) % HASH_MODULUS"},
{"lineNum":"   71","line":"  #   reduce(x * 10**e) == reduce(x) * reduce(10**e) % HASH_MODULUS"},
{"lineNum":"   72","line":"  # and reduce(10**e) can be computed efficiently by the usual modular"},
{"lineNum":"   73","line":"  # exponentiation algorithm.  For reduce(2**e) it\'s even better: since"},
{"lineNum":"   74","line":"  # P is of the form 2**n-1, reduce(2**e) is 2**(e mod n), and multiplication"},
{"lineNum":"   75","line":"  # by 2**(e mod n) modulo 2**n-1 just amounts to a rotation of bits."},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"  private HASH_BITS    = 61"},
{"lineNum":"   78","line":"  private HASH_MODULUS = (1_i64 << HASH_BITS) - 1"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"  private HASH_NAN       =      0_u64"},
{"lineNum":"   81","line":"  private HASH_INF_PLUS  = 314159_u64"},
{"lineNum":"   82","line":"  private HASH_INF_MINUS = (-314159_i64).unsafe_as(UInt64)"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"  @@seed = uninitialized UInt64[2]"},
{"lineNum":"   85","line":"  Random::Secure.random_bytes(Slice.new(pointerof(@@seed).as(UInt8*), sizeof(typeof(@@seed))))","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"  def initialize(@a : UInt64 = @@seed[0], @b : UInt64 = @@seed[1])"},
{"lineNum":"   88","line":"  end"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"  private C1 = 0xacd5ad43274593b9_u64"},
{"lineNum":"   91","line":"  private C2 = 0x6956abd6ed268a3d_u64"},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"  private def rotl32(v : UInt64)"},
{"lineNum":"   94","line":"    (v << 32) | (v >> 32)","class":"lineNoCov","hits":"0","possible_hits":"30",},
{"lineNum":"   95","line":"  end"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"  private def permute(v : UInt64)","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"   98","line":"    @a = rotl32(@a ^ v) * C1","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"   99","line":"    @b = (rotl32(@b) ^ v) * C2","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  100","line":"    self"},
{"lineNum":"  101","line":"  end"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"  def result"},
{"lineNum":"  104","line":"    a, b = @a, @b"},
{"lineNum":"  105","line":"    a ^= (a >> 23) ^ (a >> 40)","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  106","line":"    b ^= (b >> 23) ^ (b >> 40)","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  107","line":"    a *= C1","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  108","line":"    b *= C2"},
{"lineNum":"  109","line":"    a ^= a >> 32","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  110","line":"    b ^= b >> 32","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  111","line":"    a + b"},
{"lineNum":"  112","line":"  end"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"  def nil"},
{"lineNum":"  115","line":"    @a += @b"},
{"lineNum":"  116","line":"    @b += 1"},
{"lineNum":"  117","line":"    self"},
{"lineNum":"  118","line":"  end"},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"  def bool(value)"},
{"lineNum":"  121","line":"    (value ? 1 : 0).hash(self)"},
{"lineNum":"  122","line":"  end"},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"  def int(value : Int8 | Int16 | Int32)","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  125","line":"    permute(value.to_i64.unsafe_as(UInt64))"},
{"lineNum":"  126","line":"  end"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"  def int(value : UInt8 | UInt16 | UInt32)"},
{"lineNum":"  129","line":"    permute(value.to_u64)"},
{"lineNum":"  130","line":"  end"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"  def int(value : Int::Unsigned)"},
{"lineNum":"  133","line":"    permute(value.remainder(HASH_MODULUS).to_u64)"},
{"lineNum":"  134","line":"  end"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"  def int(value : Int)"},
{"lineNum":"  137","line":"    permute(value.remainder(HASH_MODULUS).to_i64.unsafe_as(UInt64))"},
{"lineNum":"  138","line":"  end"},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"  # This function is for reference implementation, and it is used for `BigFloat`."},
{"lineNum":"  141","line":"  # For `Float64` and `Float32` all supported architectures allows more effective"},
{"lineNum":"  142","line":"  # bitwise calculation."},
{"lineNum":"  143","line":"  # Arguments `frac` and `exp` are result of equivalent `Math.frexp`, though"},
{"lineNum":"  144","line":"  # for `BigFloat` custom calculation used for more precision."},
{"lineNum":"  145","line":"  private def float_normalize_reference(value, frac, exp)"},
{"lineNum":"  146","line":"    if value < 0"},
{"lineNum":"  147","line":"      frac = -frac"},
{"lineNum":"  148","line":"    end"},
{"lineNum":"  149","line":"    # process 28 bits at a time;  this should work well both for binary"},
{"lineNum":"  150","line":"    # and hexadecimal floating point."},
{"lineNum":"  151","line":"    x = 0_i64"},
{"lineNum":"  152","line":"    while frac > 0"},
{"lineNum":"  153","line":"      x = ((x << 28) & HASH_MODULUS) | x >> (HASH_BITS - 28)"},
{"lineNum":"  154","line":"      frac *= 268435456.0 # 2**28"},
{"lineNum":"  155","line":"      exp -= 28"},
{"lineNum":"  156","line":"      y = frac.to_u32 # pull out integer part"},
{"lineNum":"  157","line":"      frac -= y"},
{"lineNum":"  158","line":"      x += y"},
{"lineNum":"  159","line":"      x -= HASH_MODULUS if x >= HASH_MODULUS"},
{"lineNum":"  160","line":"    end"},
{"lineNum":"  161","line":"    {x, exp}"},
{"lineNum":"  162","line":"  end"},
{"lineNum":"  163","line":""},
{"lineNum":"  164","line":"  private def float_normalize_wrap(value)"},
{"lineNum":"  165","line":"    return HASH_NAN if value.nan?"},
{"lineNum":"  166","line":"    if value.infinite?"},
{"lineNum":"  167","line":"      return value > 0 ? HASH_INF_PLUS : HASH_INF_MINUS"},
{"lineNum":"  168","line":"    end"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"    x, exp = yield value"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"    # adjust for the exponent;  first reduce it modulo HASH_BITS"},
{"lineNum":"  173","line":"    exp = exp >= 0 ? exp % HASH_BITS : HASH_BITS - 1 - ((-1 - exp) % HASH_BITS)"},
{"lineNum":"  174","line":"    x = ((x << exp) & HASH_MODULUS) | x >> (HASH_BITS - exp)"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"    (x * (value < 0 ? -1 : 1)).to_i64.unsafe_as(UInt64)"},
{"lineNum":"  177","line":"  end"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"  def float(value : Float32)"},
{"lineNum":"  180","line":"    normalized_hash = float_normalize_wrap(value) do |value|"},
{"lineNum":"  181","line":"      # This optimized version works on every architecture where endianess"},
{"lineNum":"  182","line":"      # of Float32 and Int32 matches and float is IEEE754. All supported"},
{"lineNum":"  183","line":"      # architectures fall into this category."},
{"lineNum":"  184","line":"      unsafe_int = value.unsafe_as(Int32)"},
{"lineNum":"  185","line":"      exp = (((unsafe_int >> 23) & 0xff) - 127)"},
{"lineNum":"  186","line":"      mantissa = unsafe_int & ((1 << 23) - 1)"},
{"lineNum":"  187","line":"      if exp > -127"},
{"lineNum":"  188","line":"        exp -= 23"},
{"lineNum":"  189","line":"        mantissa |= 1 << 23"},
{"lineNum":"  190","line":"      else"},
{"lineNum":"  191","line":"        # subnormals"},
{"lineNum":"  192","line":"        exp -= 22"},
{"lineNum":"  193","line":"      end"},
{"lineNum":"  194","line":"      {mantissa.to_i64, exp}"},
{"lineNum":"  195","line":"    end"},
{"lineNum":"  196","line":"    permute(normalized_hash)"},
{"lineNum":"  197","line":"  end"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"  def float(value : Float64)"},
{"lineNum":"  200","line":"    normalized_hash = float_normalize_wrap(value) do |value|"},
{"lineNum":"  201","line":"      # This optimized version works on every architecture where endianess"},
{"lineNum":"  202","line":"      # of Float64 and Int64 matches and float is IEEE754. All supported"},
{"lineNum":"  203","line":"      # architectures fall into this category."},
{"lineNum":"  204","line":"      unsafe_int = value.unsafe_as(Int64)"},
{"lineNum":"  205","line":"      exp = (((unsafe_int >> 52) & 0x7ff) - 1023)"},
{"lineNum":"  206","line":"      mantissa = unsafe_int & ((1_u64 << 52) - 1)"},
{"lineNum":"  207","line":"      if exp > -1023"},
{"lineNum":"  208","line":"        exp -= 52"},
{"lineNum":"  209","line":"        mantissa |= 1_u64 << 52"},
{"lineNum":"  210","line":"      else"},
{"lineNum":"  211","line":"        # subnormals"},
{"lineNum":"  212","line":"        exp -= 51"},
{"lineNum":"  213","line":"      end"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"      {mantissa.to_i64, exp}"},
{"lineNum":"  216","line":"    end"},
{"lineNum":"  217","line":"    permute(normalized_hash)"},
{"lineNum":"  218","line":"  end"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"  def float(value : Float)"},
{"lineNum":"  221","line":"    normalized_hash = float_normalize_wrap(value) do |value|"},
{"lineNum":"  222","line":"      frac, exp = Math.frexp value"},
{"lineNum":"  223","line":"      float_normalize_reference(value, frac, exp)"},
{"lineNum":"  224","line":"    end"},
{"lineNum":"  225","line":"    permute(normalized_hash)"},
{"lineNum":"  226","line":"  end"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"  def char(value)"},
{"lineNum":"  229","line":"    value.ord.hash(self)"},
{"lineNum":"  230","line":"  end"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"  def enum(value)"},
{"lineNum":"  233","line":"    value.value.hash(self)"},
{"lineNum":"  234","line":"  end"},
{"lineNum":"  235","line":""},
{"lineNum":"  236","line":"  def symbol(value)"},
{"lineNum":"  237","line":"    value.to_i.hash(self)"},
{"lineNum":"  238","line":"  end"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"  def reference(value)"},
{"lineNum":"  241","line":"    permute(value.object_id.to_u64)"},
{"lineNum":"  242","line":"  end"},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"  def string(value)"},
{"lineNum":"  245","line":"    bytes(value.to_slice)"},
{"lineNum":"  246","line":"  end"},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"  private def read_u24(ptr, rest)"},
{"lineNum":"  249","line":"    ptr[0].to_u64 | (ptr[rest/2].to_u64 << 8) | (ptr[rest - 1].to_u64 << 16)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  250","line":"  end"},
{"lineNum":"  251","line":""},
{"lineNum":"  252","line":"  private def read_u32(ptr)"},
{"lineNum":"  253","line":"    # force correct unaligned read"},
{"lineNum":"  254","line":"    t4 = uninitialized UInt32"},
{"lineNum":"  255","line":"    pointerof(t4).as(UInt8*).copy_from(ptr, 4)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  256","line":"    t4.to_u64"},
{"lineNum":"  257","line":"  end"},
{"lineNum":"  258","line":""},
{"lineNum":"  259","line":"  private def read_u64(ptr)"},
{"lineNum":"  260","line":"    # force correct unaligned read"},
{"lineNum":"  261","line":"    t8 = uninitialized UInt64"},
{"lineNum":"  262","line":"    pointerof(t8).as(UInt8*).copy_from(ptr, 8)"},
{"lineNum":"  263","line":"    t8"},
{"lineNum":"  264","line":"  end"},
{"lineNum":"  265","line":""},
{"lineNum":"  266","line":"  def bytes(value : Bytes)"},
{"lineNum":"  267","line":"    size = value.size"},
{"lineNum":"  268","line":"    ptr = value.to_unsafe"},
{"lineNum":"  269","line":"    if size <= 0","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  270","line":"      last = 0_u64"},
{"lineNum":"  271","line":"    elsif size <= 3"},
{"lineNum":"  272","line":"      last = read_u24(ptr, size)"},
{"lineNum":"  273","line":"    elsif size <= 7"},
{"lineNum":"  274","line":"      last = read_u32(ptr)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  275","line":"      last |= read_u32(ptr + (size & 3)) << 32","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  276","line":"    else"},
{"lineNum":"  277","line":"      while size >= 8","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  278","line":"        permute(read_u64(ptr))"},
{"lineNum":"  279","line":"        ptr += 8","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  280","line":"        size -= 8"},
{"lineNum":"  281","line":"      end"},
{"lineNum":"  282","line":"      last = read_u64(ptr - (8 - size))","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  283","line":"    end"},
{"lineNum":"  284","line":"    @a ^= size","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  285","line":"    @b ^= size"},
{"lineNum":"  286","line":"    permute(last)"},
{"lineNum":"  287","line":"    self"},
{"lineNum":"  288","line":"  end"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"  def class(value)"},
{"lineNum":"  291","line":"    value.crystal_type_id.hash(self)"},
{"lineNum":"  292","line":"  end"},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"  def inspect(io)"},
{"lineNum":"  295","line":"    io << \"#{self.class}(hidden_state)\""},
{"lineNum":"  296","line":"    nil"},
{"lineNum":"  297","line":"  end"},
{"lineNum":"  298","line":"end"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "roman_spec", "date" : "2018-03-12 14:24:04", "instrumented" : 20, "covered" : 0,};
var merged_data = [];
