var data = {lines:[
{"lineNum":"    1","line":"require \"c/string\""},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"# A typed pointer to some memory."},
{"lineNum":"    4","line":"#"},
{"lineNum":"    5","line":"# This is the only unsafe type in Crystal. If you are using a pointer, you are writing"},
{"lineNum":"    6","line":"# unsafe code because a pointer doesn\'t know where it\'s pointing to nor how much memory"},
{"lineNum":"    7","line":"# starting from it is valid. However, pointers make it possible to interface with C and"},
{"lineNum":"    8","line":"# to implement efficient data structures. For example, both `Array` and `Hash` are"},
{"lineNum":"    9","line":"# implemented using pointers."},
{"lineNum":"   10","line":"#"},
{"lineNum":"   11","line":"# You can obtain pointers in four ways: `#new`, `#malloc`, `pointerof` and by calling a C"},
{"lineNum":"   12","line":"# function that returns a pointer."},
{"lineNum":"   13","line":"#"},
{"lineNum":"   14","line":"# `pointerof(x)`, where *x* is a variable or an instance variable, returns a pointer to"},
{"lineNum":"   15","line":"# that variable:"},
{"lineNum":"   16","line":"#"},
{"lineNum":"   17","line":"# ```"},
{"lineNum":"   18","line":"# x = 1"},
{"lineNum":"   19","line":"# ptr = pointerof(x)"},
{"lineNum":"   20","line":"# ptr.value = 2"},
{"lineNum":"   21","line":"# x # => 2"},
{"lineNum":"   22","line":"# ```"},
{"lineNum":"   23","line":"#"},
{"lineNum":"   24","line":"# Note that a pointer is *falsey* if it\'s null (if it\'s address is zero)."},
{"lineNum":"   25","line":"#"},
{"lineNum":"   26","line":"# When calling a C function that expects a pointer you can also pass `nil` instead of using"},
{"lineNum":"   27","line":"# `Pointer.null` to construct a null pointer."},
{"lineNum":"   28","line":"#"},
{"lineNum":"   29","line":"# For a safe alternative, see `Slice`, which is a pointer with a size and with bounds checking."},
{"lineNum":"   30","line":"struct Pointer(T)"},
{"lineNum":"   31","line":"  # Unsafe wrapper around a `Pointer` that allows to write values to"},
{"lineNum":"   32","line":"  # it while advancing the location and keeping track of how many elements"},
{"lineNum":"   33","line":"  # were written."},
{"lineNum":"   34","line":"  #"},
{"lineNum":"   35","line":"  # See also: `Pointer#appender`."},
{"lineNum":"   36","line":"  struct Appender(T)"},
{"lineNum":"   37","line":"    def initialize(@pointer : Pointer(T))"},
{"lineNum":"   38","line":"      @start = @pointer"},
{"lineNum":"   39","line":"    end"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"    def <<(value : T)","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"   42","line":"      @pointer.value = value"},
{"lineNum":"   43","line":"      @pointer += 1"},
{"lineNum":"   44","line":"    end"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"    def size","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   47","line":"      @pointer - @start"},
{"lineNum":"   48","line":"    end"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"    def pointer"},
{"lineNum":"   51","line":"      @pointer"},
{"lineNum":"   52","line":"    end"},
{"lineNum":"   53","line":"  end"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"  include Comparable(self)"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"  # Returns `true` if this pointer\'s address is zero."},
{"lineNum":"   58","line":"  #"},
{"lineNum":"   59","line":"  # ```"},
{"lineNum":"   60","line":"  # a = 1"},
{"lineNum":"   61","line":"  # pointerof(a).null? # => false"},
{"lineNum":"   62","line":"  #"},
{"lineNum":"   63","line":"  # b = Pointer(Int32).new(0)"},
{"lineNum":"   64","line":"  # b.null? # => true"},
{"lineNum":"   65","line":"  # ```"},
{"lineNum":"   66","line":"  def null?","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   67","line":"    address == 0"},
{"lineNum":"   68","line":"  end"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"  # Returns a new pointer whose address is this pointer\'s address incremented by `other * sizeof(T)`."},
{"lineNum":"   71","line":"  #"},
{"lineNum":"   72","line":"  # ```"},
{"lineNum":"   73","line":"  # ptr = Pointer(Int32).new(1234)"},
{"lineNum":"   74","line":"  # ptr.address # => 1234"},
{"lineNum":"   75","line":"  #"},
{"lineNum":"   76","line":"  # # An Int32 occupies four bytes"},
{"lineNum":"   77","line":"  # ptr2 = ptr + 1"},
{"lineNum":"   78","line":"  # ptr2.address # => 1238"},
{"lineNum":"   79","line":"  # ```"},
{"lineNum":"   80","line":"  def +(other : Int)","class":"lineNoCov","hits":"0","possible_hits":"618",},
{"lineNum":"   81","line":"    self + other.to_i64"},
{"lineNum":"   82","line":"  end"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"  # Returns a new pointer whose address is this pointer\'s address decremented by `other * sizeof(T)`."},
{"lineNum":"   85","line":"  #"},
{"lineNum":"   86","line":"  # ```"},
{"lineNum":"   87","line":"  # ptr = Pointer(Int32).new(1234)"},
{"lineNum":"   88","line":"  # ptr.address # => 1234"},
{"lineNum":"   89","line":"  #"},
{"lineNum":"   90","line":"  # # An Int32 occupies four bytes"},
{"lineNum":"   91","line":"  # ptr2 = ptr - 1"},
{"lineNum":"   92","line":"  # ptr2.address # => 1230"},
{"lineNum":"   93","line":"  # ```"},
{"lineNum":"   94","line":"  def -(other : Int)"},
{"lineNum":"   95","line":"    self + (-other)"},
{"lineNum":"   96","line":"  end"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"  # Returns -1, 0 or 1 if this pointer\'s address is less, equal or greater than *other*\'s address,"},
{"lineNum":"   99","line":"  # respectively."},
{"lineNum":"  100","line":"  #"},
{"lineNum":"  101","line":"  # See also: `Object#<=>`."},
{"lineNum":"  102","line":"  def <=>(other : self)"},
{"lineNum":"  103","line":"    address <=> other.address"},
{"lineNum":"  104","line":"  end"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"  # Gets the value pointed at this pointer\'s address plus `offset * sizeof(T)`."},
{"lineNum":"  107","line":"  #"},
{"lineNum":"  108","line":"  # ```"},
{"lineNum":"  109","line":"  # ptr = Pointer.malloc(4) { |i| i + 10 }"},
{"lineNum":"  110","line":"  # ptr[0] # => 10"},
{"lineNum":"  111","line":"  # ptr[1] # => 11"},
{"lineNum":"  112","line":"  # ptr[2] # => 12"},
{"lineNum":"  113","line":"  # ptr[3] # => 13"},
{"lineNum":"  114","line":"  # ```"},
{"lineNum":"  115","line":"  def [](offset)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  116","line":"    (self + offset).value","class":"lineNoCov","hits":"0","possible_hits":"317",},
{"lineNum":"  117","line":"  end"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"  # Sets the value pointed at this pointer\'s address plus `offset * sizeof(T)`."},
{"lineNum":"  120","line":"  #"},
{"lineNum":"  121","line":"  # ```"},
{"lineNum":"  122","line":"  # ptr = Pointer(Int32).malloc(4) # [0, 0, 0, 0]"},
{"lineNum":"  123","line":"  # ptr[1] = 42"},
{"lineNum":"  124","line":"  #"},
{"lineNum":"  125","line":"  # ptr2 = ptr + 1"},
{"lineNum":"  126","line":"  # ptr2.value # => 42"},
{"lineNum":"  127","line":"  # ```"},
{"lineNum":"  128","line":"  def []=(offset, value : T)","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  129","line":"    (self + offset).value = value","class":"lineNoCov","hits":"0","possible_hits":"194",},
{"lineNum":"  130","line":"  end"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"  # Copies *count* elements from *source* into `self`."},
{"lineNum":"  133","line":"  # If *source* and `self` overlap, behaviour is undefined."},
{"lineNum":"  134","line":"  # Use `#move_from` if they overlap (slower but always works)."},
{"lineNum":"  135","line":"  #"},
{"lineNum":"  136","line":"  # ```"},
{"lineNum":"  137","line":"  # ptr1 = Pointer.malloc(4) { |i| i + 1 }  # [1, 2, 3, 4]"},
{"lineNum":"  138","line":"  # ptr2 = Pointer.malloc(4) { |i| i + 11 } # [11, 12, 13, 14]"},
{"lineNum":"  139","line":"  #"},
{"lineNum":"  140","line":"  # # ptr2 -> [11, 12, 13, 14]"},
{"lineNum":"  141","line":"  # #          ^---^           <- copy this"},
{"lineNum":"  142","line":"  # # ptr1 -> [1,  2,  3,  4]"},
{"lineNum":"  143","line":"  # #          ^---^           <- here"},
{"lineNum":"  144","line":"  # ptr1.copy_from(ptr2, 2)"},
{"lineNum":"  145","line":"  # ptr1[0] # => 11"},
{"lineNum":"  146","line":"  # ptr1[1] # => 12"},
{"lineNum":"  147","line":"  # ptr1[2] # => 3"},
{"lineNum":"  148","line":"  # ptr1[3] # => 4"},
{"lineNum":"  149","line":"  # ```"},
{"lineNum":"  150","line":"  def copy_from(source : Pointer(T), count : Int)"},
{"lineNum":"  151","line":"    source.copy_to(self, count)"},
{"lineNum":"  152","line":"  end"},
{"lineNum":"  153","line":"","class":"lineNoCov","hits":"0","possible_hits":"91",},
{"lineNum":"  154","line":"  # :nodoc:"},
{"lineNum":"  155","line":"  def copy_from(source : Pointer(NoReturn), count : Int)"},
{"lineNum":"  156","line":"    raise ArgumentError.new(\"Negative count\") if count < 0"},
{"lineNum":"  157","line":""},
{"lineNum":"  158","line":"    # We need this overload for cases when we have a pointer to unreachable"},
{"lineNum":"  159","line":"    # data, like when doing Tuple.new.to_a"},
{"lineNum":"  160","line":"    self"},
{"lineNum":"  161","line":"  end"},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"  # Copies *count* elements from `self` into *target*."},
{"lineNum":"  164","line":"  # If `self` and *target* overlap, behaviour is undefined."},
{"lineNum":"  165","line":"  # Use `#move_to` if they overlap (slower but always works)."},
{"lineNum":"  166","line":"  #"},
{"lineNum":"  167","line":"  # ```"},
{"lineNum":"  168","line":"  # ptr1 = Pointer.malloc(4) { |i| i + 1 }  # [1, 2, 3, 4]"},
{"lineNum":"  169","line":"  # ptr2 = Pointer.malloc(4) { |i| i + 11 } # [11, 12, 13, 14]"},
{"lineNum":"  170","line":"  #"},
{"lineNum":"  171","line":"  # # ptr1 -> [1,  2,  3,  4]"},
{"lineNum":"  172","line":"  # #          ^---^           <- copy this"},
{"lineNum":"  173","line":"  # # ptr2 -> [11, 12, 13, 14]"},
{"lineNum":"  174","line":"  # #          ^---^           <- here"},
{"lineNum":"  175","line":"  # ptr1.copy_to(ptr2, 2)"},
{"lineNum":"  176","line":"  # ptr2[0] # => 1"},
{"lineNum":"  177","line":"  # ptr2[1] # => 2"},
{"lineNum":"  178","line":"  # ptr2[2] # => 13"},
{"lineNum":"  179","line":"  # ptr2[3] # => 14"},
{"lineNum":"  180","line":"  # ```"},
{"lineNum":"  181","line":"  def copy_to(target : Pointer, count : Int)"},
{"lineNum":"  182","line":"    target.copy_from_impl(self, count)"},
{"lineNum":"  183","line":"  end"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"  # Copies *count* elements from *source* into `self`."},
{"lineNum":"  186","line":"  # *source* and `self` may overlap; the copy is always done in a non-destructive manner."},
{"lineNum":"  187","line":"  #"},
{"lineNum":"  188","line":"  # ```"},
{"lineNum":"  189","line":"  # ptr1 = Pointer.malloc(4) { |i| i + 1 } # ptr1 -> [1, 2, 3, 4]"},
{"lineNum":"  190","line":"  # ptr2 = ptr1 + 1                        #             ^--------- ptr2"},
{"lineNum":"  191","line":"  #"},
{"lineNum":"  192","line":"  # # [1, 2, 3, 4]"},
{"lineNum":"  193","line":"  # #  ^-----^       <- copy this"},
{"lineNum":"  194","line":"  # #     ^------^   <- here"},
{"lineNum":"  195","line":"  # ptr2.move_from(ptr1, 3)"},
{"lineNum":"  196","line":"  #"},
{"lineNum":"  197","line":"  # ptr1[0] # => 1"},
{"lineNum":"  198","line":"  # ptr1[1] # => 1"},
{"lineNum":"  199","line":"  # ptr1[2] # => 2"},
{"lineNum":"  200","line":"  # ptr1[3] # => 3"},
{"lineNum":"  201","line":"  # ```"},
{"lineNum":"  202","line":"  def move_from(source : Pointer(T), count : Int)"},
{"lineNum":"  203","line":"    source.move_to(self, count)"},
{"lineNum":"  204","line":"  end"},
{"lineNum":"  205","line":""},
{"lineNum":"  206","line":"  # :nodoc:"},
{"lineNum":"  207","line":"  def move_from(source : Pointer(NoReturn), count : Int)"},
{"lineNum":"  208","line":"    raise ArgumentError.new(\"Negative count\") if count < 0"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"    # We need this overload for cases when we have a pointer to unreachable"},
{"lineNum":"  211","line":"    # data, like when doing Tuple.new.to_a"},
{"lineNum":"  212","line":"    self"},
{"lineNum":"  213","line":"  end"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"  # Copies *count* elements from `self` into *source*."},
{"lineNum":"  216","line":"  # *source* and `self` may overlap; the copy is always done in a non-destructive manner."},
{"lineNum":"  217","line":"  #"},
{"lineNum":"  218","line":"  # ```"},
{"lineNum":"  219","line":"  # ptr1 = Pointer.malloc(4) { |i| i + 1 } # ptr1 -> [1, 2, 3, 4]"},
{"lineNum":"  220","line":"  # ptr2 = ptr1 + 1                        #             ^--------- ptr2"},
{"lineNum":"  221","line":"  #"},
{"lineNum":"  222","line":"  # # [1, 2, 3, 4]"},
{"lineNum":"  223","line":"  # #  ^-----^       <- copy this"},
{"lineNum":"  224","line":"  # #     ^------^   <- here"},
{"lineNum":"  225","line":"  # ptr1.move_to(ptr2, 3)"},
{"lineNum":"  226","line":"  #"},
{"lineNum":"  227","line":"  # ptr1[0] # => 1"},
{"lineNum":"  228","line":"  # ptr1[1] # => 1"},
{"lineNum":"  229","line":"  # ptr1[2] # => 2"},
{"lineNum":"  230","line":"  # ptr1[3] # => 3"},
{"lineNum":"  231","line":"  # ```"},
{"lineNum":"  232","line":"  def move_to(target : Pointer, count : Int)"},
{"lineNum":"  233","line":"    target.move_from_impl(self, count)"},
{"lineNum":"  234","line":"  end"},
{"lineNum":"  235","line":""},
{"lineNum":"  236","line":"  # We use separate method in which we make sure that `source`"},
{"lineNum":"  237","line":"  # is never a union of pointers. This is guaranteed because both"},
{"lineNum":"  238","line":"  # copy_from/move_from/copy_to/move_to reverse self and caller,"},
{"lineNum":"  239","line":"  # and so if either self or the arguments are unions a dispatch"},
{"lineNum":"  240","line":"  # will happen and unions will disappear."},
{"lineNum":"  241","line":"  protected def copy_from_impl(source : Pointer(T), count : Int)"},
{"lineNum":"  242","line":"    raise ArgumentError.new(\"Negative count\") if count < 0","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"    if self.class == source.class"},
{"lineNum":"  245","line":"      Intrinsics.memcpy(self.as(Void*), source.as(Void*), bytesize(count), 0_u32, false)","class":"lineNoCov","hits":"0","possible_hits":"74",},
{"lineNum":"  246","line":"    else"},
{"lineNum":"  247","line":"      while (count -= 1) >= 0"},
{"lineNum":"  248","line":"        self[count] = source[count]"},
{"lineNum":"  249","line":"      end"},
{"lineNum":"  250","line":"    end"},
{"lineNum":"  251","line":"    self"},
{"lineNum":"  252","line":"  end"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"  protected def move_from_impl(source : Pointer(T), count : Int)"},
{"lineNum":"  255","line":"    raise ArgumentError.new(\"Negative count\") if count < 0","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  256","line":""},
{"lineNum":"  257","line":"    if self.class == source.class"},
{"lineNum":"  258","line":"      Intrinsics.memmove(self.as(Void*), source.as(Void*), bytesize(count), 0_u32, false)","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  259","line":"    else"},
{"lineNum":"  260","line":"      if source.address < address"},
{"lineNum":"  261","line":"        copy_from source, count"},
{"lineNum":"  262","line":"      else"},
{"lineNum":"  263","line":"        count.times do |i|"},
{"lineNum":"  264","line":"          self[i] = source[i]"},
{"lineNum":"  265","line":"        end"},
{"lineNum":"  266","line":"      end"},
{"lineNum":"  267","line":"    end"},
{"lineNum":"  268","line":"    self"},
{"lineNum":"  269","line":"  end"},
{"lineNum":"  270","line":""},
{"lineNum":"  271","line":"  # Compares *count* elements from this pointer and *other*, byte by byte."},
{"lineNum":"  272","line":"  #"},
{"lineNum":"  273","line":"  # Returns 0 if both pointers point to the same sequence of *count* bytes. Otherwise"},
{"lineNum":"  274","line":"  # returns the difference between the first two differing bytes (treated as UInt8)."},
{"lineNum":"  275","line":"  #"},
{"lineNum":"  276","line":"  # ```"},
{"lineNum":"  277","line":"  # ptr1 = Pointer.malloc(4) { |i| i + 1 }  # [1, 2, 3, 4]"},
{"lineNum":"  278","line":"  # ptr2 = Pointer.malloc(4) { |i| i + 11 } # [11, 12, 13, 14]"},
{"lineNum":"  279","line":"  #"},
{"lineNum":"  280","line":"  # ptr1.memcmp(ptr2, 4) # => -10"},
{"lineNum":"  281","line":"  # ptr2.memcmp(ptr1, 4) # => 10"},
{"lineNum":"  282","line":"  # ptr1.memcmp(ptr1, 4) # => 0"},
{"lineNum":"  283","line":"  # ```"},
{"lineNum":"  284","line":"  def memcmp(other : Pointer(T), count : Int)"},
{"lineNum":"  285","line":"    LibC.memcmp(self.as(Void*), (other.as(Void*)), (count * sizeof(T)))","class":"lineNoCov","hits":"0","possible_hits":"56",},
{"lineNum":"  286","line":"  end"},
{"lineNum":"  287","line":""},
{"lineNum":"  288","line":"  # Swaps the contents pointed at the offsets *i* and *j*."},
{"lineNum":"  289","line":"  #"},
{"lineNum":"  290","line":"  # ```"},
{"lineNum":"  291","line":"  # ptr = Pointer.malloc(4) { |i| i + 1 }"},
{"lineNum":"  292","line":"  # ptr[2] # => 3"},
{"lineNum":"  293","line":"  # ptr[3] # => 4"},
{"lineNum":"  294","line":"  # ptr.swap(2, 3)"},
{"lineNum":"  295","line":"  # ptr[2] # => 4"},
{"lineNum":"  296","line":"  # ptr[3] # => 3"},
{"lineNum":"  297","line":"  # ```"},
{"lineNum":"  298","line":"  def swap(i, j)"},
{"lineNum":"  299","line":"    self[i], self[j] = self[j], self[i]"},
{"lineNum":"  300","line":"  end"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"  # Returns the address of this pointer."},
{"lineNum":"  303","line":"  #"},
{"lineNum":"  304","line":"  # ```"},
{"lineNum":"  305","line":"  # ptr = Pointer(Int32).new(1234)"},
{"lineNum":"  306","line":"  # ptr.hash # => 1234"},
{"lineNum":"  307","line":"  # ```"},
{"lineNum":"  308","line":"  def_hash address"},
{"lineNum":"  309","line":""},
{"lineNum":"  310","line":"  # Appends a string representation of this pointer to the given `IO`,"},
{"lineNum":"  311","line":"  # including its type and address in hexadecimal."},
{"lineNum":"  312","line":"  #"},
{"lineNum":"  313","line":"  # ```"},
{"lineNum":"  314","line":"  # ptr1 = Pointer(Int32).new(1234)"},
{"lineNum":"  315","line":"  # ptr1.to_s # => \"Pointer(Int32)@0x4d2\""},
{"lineNum":"  316","line":"  #"},
{"lineNum":"  317","line":"  # ptr2 = Pointer(Int32).new(0)"},
{"lineNum":"  318","line":"  # ptr2.to_s # => \"Pointer(Int32).null\""},
{"lineNum":"  319","line":"  # ```"},
{"lineNum":"  320","line":"  def to_s(io : IO)"},
{"lineNum":"  321","line":"    io << \"Pointer(\""},
{"lineNum":"  322","line":"    io << T.to_s"},
{"lineNum":"  323","line":"    io << \")\""},
{"lineNum":"  324","line":"    if address == 0"},
{"lineNum":"  325","line":"      io << \".null\""},
{"lineNum":"  326","line":"    else"},
{"lineNum":"  327","line":"      io << \"@0x\""},
{"lineNum":"  328","line":"      address.to_s(16, io)"},
{"lineNum":"  329","line":"    end"},
{"lineNum":"  330","line":"  end"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"  # Tries to change the size of the allocation pointed to by this pointer to *size*,"},
{"lineNum":"  333","line":"  # and returns that pointer."},
{"lineNum":"  334","line":"  #"},
{"lineNum":"  335","line":"  # Since the space after the end of the block may be in use, realloc may find it"},
{"lineNum":"  336","line":"  # necessary to copy the block to a new address where more free space is available."},
{"lineNum":"  337","line":"  # The value of realloc is the new address of the block."},
{"lineNum":"  338","line":"  # If the block needs to be moved, realloc copies the old contents."},
{"lineNum":"  339","line":"  #"},
{"lineNum":"  340","line":"  # Remember to always assign the value of realloc."},
{"lineNum":"  341","line":"  #"},
{"lineNum":"  342","line":"  # ```"},
{"lineNum":"  343","line":"  # ptr = Pointer.malloc(4) { |i| i + 1 } # [1, 2, 3, 4]"},
{"lineNum":"  344","line":"  # ptr = ptr.realloc(8)"},
{"lineNum":"  345","line":"  # ptr # [1, 2, 3, 4, 0, 0, 0, 0]"},
{"lineNum":"  346","line":"  # ```"},
{"lineNum":"  347","line":"  def realloc(size : Int)"},
{"lineNum":"  348","line":"    if size < 0","class":"lineNoCov","hits":"0","possible_hits":"32",},
{"lineNum":"  349","line":"      raise ArgumentError.new(\"Negative size\")","class":"lineNoCov","hits":"0","possible_hits":"58",},
{"lineNum":"  350","line":"    end"},
{"lineNum":"  351","line":""},
{"lineNum":"  352","line":"    realloc(size.to_u64)"},
{"lineNum":"  353","line":"  end"},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"  # Shuffles *count* consecutive values pointed by this pointer."},
{"lineNum":"  356","line":"  #"},
{"lineNum":"  357","line":"  # ```"},
{"lineNum":"  358","line":"  # ptr = Pointer.malloc(4) { |i| i + 1 } # [1, 2, 3, 4]"},
{"lineNum":"  359","line":"  # ptr.shuffle!(4)"},
{"lineNum":"  360","line":"  # ptr # [3, 4, 1, 2]"},
{"lineNum":"  361","line":"  # ```"},
{"lineNum":"  362","line":"  def shuffle!(count : Int, random = Random::DEFAULT)"},
{"lineNum":"  363","line":"    (count - 1).downto(1) do |i|"},
{"lineNum":"  364","line":"      j = random.rand(i + 1)"},
{"lineNum":"  365","line":"      swap(i, j)"},
{"lineNum":"  366","line":"    end"},
{"lineNum":"  367","line":"    self"},
{"lineNum":"  368","line":"  end"},
{"lineNum":"  369","line":""},
{"lineNum":"  370","line":"  # Sets *count* consecutive values pointed by this pointer to the"},
{"lineNum":"  371","line":"  # values returned by the block."},
{"lineNum":"  372","line":"  #"},
{"lineNum":"  373","line":"  # ```"},
{"lineNum":"  374","line":"  # ptr = Pointer.malloc(4) { |i| i + 1 } # [1, 2, 3, 4]"},
{"lineNum":"  375","line":"  # ptr.map!(4) { |value| value * 2 }"},
{"lineNum":"  376","line":"  # ptr # [2, 4, 6, 8]"},
{"lineNum":"  377","line":"  # ```"},
{"lineNum":"  378","line":"  def map!(count : Int)"},
{"lineNum":"  379","line":"    count.times do |i|"},
{"lineNum":"  380","line":"      self[i] = yield self[i]"},
{"lineNum":"  381","line":"    end"},
{"lineNum":"  382","line":"  end"},
{"lineNum":"  383","line":""},
{"lineNum":"  384","line":"  # Like `map!`, but yield 2 arugments, the element and it\'s index"},
{"lineNum":"  385","line":"  def map_with_index!(count : Int, &block)"},
{"lineNum":"  386","line":"    count.times do |i|"},
{"lineNum":"  387","line":"      self[i] = yield self[i], i"},
{"lineNum":"  388","line":"    end"},
{"lineNum":"  389","line":"    self"},
{"lineNum":"  390","line":"  end"},
{"lineNum":"  391","line":""},
{"lineNum":"  392","line":"  # Returns a pointer whose memory address is zero. This doesn\'t allocate memory."},
{"lineNum":"  393","line":"  #"},
{"lineNum":"  394","line":"  # When calling a C function you can also pass `nil` instead of constructing a"},
{"lineNum":"  395","line":"  # null pointer with this method."},
{"lineNum":"  396","line":"  #"},
{"lineNum":"  397","line":"  # ```"},
{"lineNum":"  398","line":"  # ptr = Pointer(Int32).null"},
{"lineNum":"  399","line":"  # ptr.address # => 0"},
{"lineNum":"  400","line":"  # ```"},
{"lineNum":"  401","line":"  def self.null"},
{"lineNum":"  402","line":"    new 0_u64"},
{"lineNum":"  403","line":"  end"},
{"lineNum":"  404","line":""},
{"lineNum":"  405","line":"  # Returns a pointer that points to the given memory address. This doesn\'t allocate memory."},
{"lineNum":"  406","line":"  #"},
{"lineNum":"  407","line":"  # ```"},
{"lineNum":"  408","line":"  # ptr = Pointer(Int32).new(5678)"},
{"lineNum":"  409","line":"  # ptr.address # => 5678"},
{"lineNum":"  410","line":"  # ```"},
{"lineNum":"  411","line":"  def self.new(address : Int)"},
{"lineNum":"  412","line":"    new address.to_u64"},
{"lineNum":"  413","line":"  end"},
{"lineNum":"  414","line":""},
{"lineNum":"  415","line":"  # Allocates `size * sizeof(T)` bytes from the system\'s heap initialized"},
{"lineNum":"  416","line":"  # to zero and returns a pointer to the first byte from that memory."},
{"lineNum":"  417","line":"  # The memory is allocated by the `GC`, so when there are"},
{"lineNum":"  418","line":"  # no pointers to this memory, it will be automatically freed."},
{"lineNum":"  419","line":"  #"},
{"lineNum":"  420","line":"  # ```"},
{"lineNum":"  421","line":"  # # Allocate memory for an Int32: 4 bytes"},
{"lineNum":"  422","line":"  # ptr = Pointer(Int32).malloc"},
{"lineNum":"  423","line":"  # ptr.value # => 0"},
{"lineNum":"  424","line":"  #"},
{"lineNum":"  425","line":"  # # Allocate memory for 10 Int32: 40 bytes"},
{"lineNum":"  426","line":"  # ptr = Pointer(Int32).malloc(10)"},
{"lineNum":"  427","line":"  # ptr[0] # => 0"},
{"lineNum":"  428","line":"  # # ..."},
{"lineNum":"  429","line":"  # ptr[9] # => 0"},
{"lineNum":"  430","line":"  # ```"},
{"lineNum":"  431","line":"  def self.malloc(size : Int = 1)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  432","line":"    if size < 0","class":"lineNoCov","hits":"0","possible_hits":"22",},
{"lineNum":"  433","line":"      raise ArgumentError.new(\"Negative Pointer#malloc size\")","class":"lineNoCov","hits":"0","possible_hits":"47",},
{"lineNum":"  434","line":"    end"},
{"lineNum":"  435","line":""},
{"lineNum":"  436","line":"    malloc(size.to_u64)"},
{"lineNum":"  437","line":"  end"},
{"lineNum":"  438","line":""},
{"lineNum":"  439","line":"  # Allocates `size * sizeof(T)` bytes from the system\'s heap initialized"},
{"lineNum":"  440","line":"  # to *value* and returns a pointer to the first byte from that memory."},
{"lineNum":"  441","line":"  # The memory is allocated by the `GC`, so when there are"},
{"lineNum":"  442","line":"  # no pointers to this memory, it will be automatically freed."},
{"lineNum":"  443","line":"  #"},
{"lineNum":"  444","line":"  # ```"},
{"lineNum":"  445","line":"  # # An Int32 occupies 4 bytes, so here we are requesting 8 bytes"},
{"lineNum":"  446","line":"  # # initialized to the number 42"},
{"lineNum":"  447","line":"  # ptr = Pointer.malloc(2, 42)"},
{"lineNum":"  448","line":"  # ptr[0] # => 42"},
{"lineNum":"  449","line":"  # ptr[1] # => 42"},
{"lineNum":"  450","line":"  # ```"},
{"lineNum":"  451","line":"  def self.malloc(size : Int, value : T)"},
{"lineNum":"  452","line":"    ptr = Pointer(T).malloc(size)"},
{"lineNum":"  453","line":"    size.times { |i| ptr[i] = value }"},
{"lineNum":"  454","line":"    ptr"},
{"lineNum":"  455","line":"  end"},
{"lineNum":"  456","line":""},
{"lineNum":"  457","line":"  # Allocates `size * sizeof(T)` bytes from the system\'s heap initialized"},
{"lineNum":"  458","line":"  # to the value returned by the block (which is invoked once with each index in the range `0...size`)"},
{"lineNum":"  459","line":"  # and returns a pointer to the first byte from that memory."},
{"lineNum":"  460","line":"  # The memory is allocated by the `GC`, so when there are"},
{"lineNum":"  461","line":"  # no pointers to this memory, it will be automatically freed."},
{"lineNum":"  462","line":"  #"},
{"lineNum":"  463","line":"  # ```"},
{"lineNum":"  464","line":"  # # An Int32 occupies 4 bytes, so here we are requesting 16 bytes."},
{"lineNum":"  465","line":"  # # i is an index in the range 0 .. 3"},
{"lineNum":"  466","line":"  # ptr = Pointer.malloc(4) { |i| i + 10 }"},
{"lineNum":"  467","line":"  # ptr[0] # => 10"},
{"lineNum":"  468","line":"  # ptr[1] # => 11"},
{"lineNum":"  469","line":"  # ptr[2] # => 12"},
{"lineNum":"  470","line":"  # ptr[3] # => 13"},
{"lineNum":"  471","line":"  # ```"},
{"lineNum":"  472","line":"  def self.malloc(size : Int, &block : Int32 -> T)"},
{"lineNum":"  473","line":"    ptr = Pointer(T).malloc(size)"},
{"lineNum":"  474","line":"    size.times { |i| ptr[i] = yield i }"},
{"lineNum":"  475","line":"    ptr"},
{"lineNum":"  476","line":"  end"},
{"lineNum":"  477","line":""},
{"lineNum":"  478","line":"  # Returns a `Pointer::Appender` for this pointer."},
{"lineNum":"  479","line":"  def appender"},
{"lineNum":"  480","line":"    Pointer::Appender.new(self)"},
{"lineNum":"  481","line":"  end"},
{"lineNum":"  482","line":""},
{"lineNum":"  483","line":"  # Returns a `Slice` that points to this pointer and is bounded by the given *size*."},
{"lineNum":"  484","line":"  #"},
{"lineNum":"  485","line":"  # ```"},
{"lineNum":"  486","line":"  # ptr = Pointer.malloc(6) { |i| i + 10 } # [10, 11, 12, 13, 14, 15]"},
{"lineNum":"  487","line":"  # slice = ptr.to_slice(4)                # => Slice[10, 11, 12, 13]"},
{"lineNum":"  488","line":"  # slice.class                            # => Slice(Int32)"},
{"lineNum":"  489","line":"  # ```"},
{"lineNum":"  490","line":"  def to_slice(size)"},
{"lineNum":"  491","line":"    Slice.new(self, size)"},
{"lineNum":"  492","line":"  end"},
{"lineNum":"  493","line":""},
{"lineNum":"  494","line":"  # Clears (sets to \"zero\" bytes) a number of values pointed by this pointer."},
{"lineNum":"  495","line":"  #"},
{"lineNum":"  496","line":"  # ```"},
{"lineNum":"  497","line":"  # ptr = Pointer.malloc(6) { |i| i + 10 } # [10, 11, 12, 13, 14, 15]"},
{"lineNum":"  498","line":"  # ptr.clear(3)"},
{"lineNum":"  499","line":"  # ptr.to_slice(6) # => Slice[0, 0, 0, 13, 14, 15]"},
{"lineNum":"  500","line":"  # ```"},
{"lineNum":"  501","line":"  def clear(count = 1)"},
{"lineNum":"  502","line":"    Intrinsics.memset(self.as(Void*), 0_u8, bytesize(count), 0_u32, false)","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  503","line":"  end"},
{"lineNum":"  504","line":""},
{"lineNum":"  505","line":"  def clone"},
{"lineNum":"  506","line":"    self"},
{"lineNum":"  507","line":"  end"},
{"lineNum":"  508","line":""},
{"lineNum":"  509","line":"  private def bytesize(count)","class":"lineNoCov","hits":"0","possible_hits":"65",},
{"lineNum":"  510","line":"    {% if flag?(:bits64) %}"},
{"lineNum":"  511","line":"      count.to_u64 * sizeof(T)"},
{"lineNum":"  512","line":"    {% else %}"},
{"lineNum":"  513","line":"      if count > UInt32::MAX"},
{"lineNum":"  514","line":"        raise ArgumentError.new(\"Given count is bigger than UInt32::MAX\")"},
{"lineNum":"  515","line":"      end"},
{"lineNum":"  516","line":""},
{"lineNum":"  517","line":"      count.to_u32 * sizeof(T)"},
{"lineNum":"  518","line":"    {% end %}"},
{"lineNum":"  519","line":"  end"},
{"lineNum":"  520","line":"end"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "roman_spec", "date" : "2018-03-12 14:57:27", "instrumented" : 21, "covered" : 0,};
var merged_data = [];
