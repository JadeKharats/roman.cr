var data = {lines:[
{"lineNum":"    1","line":"require \"c/signal\""},
{"lineNum":"    2","line":"require \"c/stdlib\""},
{"lineNum":"    3","line":"require \"c/sys/times\""},
{"lineNum":"    4","line":"require \"c/sys/wait\""},
{"lineNum":"    5","line":"require \"c/unistd\""},
{"lineNum":"    6","line":""},
{"lineNum":"    7","line":"class Process"},
{"lineNum":"    8","line":"  # Terminate the current process immediately. All open files, pipes and sockets"},
{"lineNum":"    9","line":"  # are flushed and closed, all child processes are inherited by PID 1. This does"},
{"lineNum":"   10","line":"  # not run any handlers registered with `at_exit`, use `::exit` for that."},
{"lineNum":"   11","line":"  #"},
{"lineNum":"   12","line":"  # *status* is the exit status of the current process."},
{"lineNum":"   13","line":"  def self.exit(status = 0)"},
{"lineNum":"   14","line":"    LibC.exit(status)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   15","line":"  end"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"  # Returns the process identifier of the current process."},
{"lineNum":"   18","line":"  def self.pid : LibC::PidT"},
{"lineNum":"   19","line":"    LibC.getpid"},
{"lineNum":"   20","line":"  end"},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"  # Returns the process group identifier of the current process."},
{"lineNum":"   23","line":"  def self.pgid : LibC::PidT"},
{"lineNum":"   24","line":"    pgid(0)"},
{"lineNum":"   25","line":"  end"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"  # Returns the process group identifier of the process identified by *pid*."},
{"lineNum":"   28","line":"  def self.pgid(pid : Int32) : LibC::PidT"},
{"lineNum":"   29","line":"    ret = LibC.getpgid(pid)"},
{"lineNum":"   30","line":"    raise Errno.new(\"getpgid\") if ret < 0"},
{"lineNum":"   31","line":"    ret"},
{"lineNum":"   32","line":"  end"},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"  # Returns the process identifier of the parent process of the current process."},
{"lineNum":"   35","line":"  def self.ppid : LibC::PidT"},
{"lineNum":"   36","line":"    LibC.getppid"},
{"lineNum":"   37","line":"  end"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"  # Sends a *signal* to the processes identified by the given *pids*."},
{"lineNum":"   40","line":"  def self.kill(signal : Signal, *pids : Int)"},
{"lineNum":"   41","line":"    pids.each do |pid|"},
{"lineNum":"   42","line":"      ret = LibC.kill(pid, signal.value)"},
{"lineNum":"   43","line":"      raise Errno.new(\"kill\") if ret < 0"},
{"lineNum":"   44","line":"    end"},
{"lineNum":"   45","line":"    nil"},
{"lineNum":"   46","line":"  end"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"  # Returns `true` if the process identified by *pid* is valid for"},
{"lineNum":"   49","line":"  # a currently registered process, `false` otherwise. Note that this"},
{"lineNum":"   50","line":"  # returns `true` for a process in the zombie or similar state."},
{"lineNum":"   51","line":"  def self.exists?(pid : Int)"},
{"lineNum":"   52","line":"    ret = LibC.kill(pid, 0)"},
{"lineNum":"   53","line":"    if ret == 0"},
{"lineNum":"   54","line":"      true"},
{"lineNum":"   55","line":"    else"},
{"lineNum":"   56","line":"      return false if Errno.value == Errno::ESRCH"},
{"lineNum":"   57","line":"      raise Errno.new(\"kill\")"},
{"lineNum":"   58","line":"    end"},
{"lineNum":"   59","line":"  end"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"  # A struct representing the CPU current times of the process,"},
{"lineNum":"   62","line":"  # in fractions of seconds."},
{"lineNum":"   63","line":"  #"},
{"lineNum":"   64","line":"  # * *utime*: CPU time a process spent in userland."},
{"lineNum":"   65","line":"  # * *stime*: CPU time a process spent in the kernel."},
{"lineNum":"   66","line":"  # * *cutime*: CPU time a processes terminated children (and their terminated children) spent in the userland."},
{"lineNum":"   67","line":"  # * *cstime*: CPU time a processes terminated children (and their terminated children) spent in the kernel."},
{"lineNum":"   68","line":"  record Tms, utime : Float64, stime : Float64, cutime : Float64, cstime : Float64"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"  # Returns a `Tms` for the current process. For the children times, only those"},
{"lineNum":"   71","line":"  # of terminated children are returned."},
{"lineNum":"   72","line":"  def self.times : Tms"},
{"lineNum":"   73","line":"    hertz = LibC.sysconf(LibC::SC_CLK_TCK).to_f"},
{"lineNum":"   74","line":"    LibC.times(out tms)"},
{"lineNum":"   75","line":"    Tms.new(tms.tms_utime / hertz, tms.tms_stime / hertz, tms.tms_cutime / hertz, tms.tms_cstime / hertz)"},
{"lineNum":"   76","line":"  end"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"  # Runs the given block inside a new process and"},
{"lineNum":"   79","line":"  # returns a `Process` representing the new child process."},
{"lineNum":"   80","line":"  def self.fork"},
{"lineNum":"   81","line":"    pid = fork_internal do"},
{"lineNum":"   82","line":"      with self yield self"},
{"lineNum":"   83","line":"    end"},
{"lineNum":"   84","line":"    new pid"},
{"lineNum":"   85","line":"  end"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"  # Duplicates the current process."},
{"lineNum":"   88","line":"  # Returns a `Process` representing the new child process in the current process"},
{"lineNum":"   89","line":"  # and `nil` inside the new child process."},
{"lineNum":"   90","line":"  def self.fork : self?"},
{"lineNum":"   91","line":"    if pid = fork_internal"},
{"lineNum":"   92","line":"      new pid"},
{"lineNum":"   93","line":"    else"},
{"lineNum":"   94","line":"      nil"},
{"lineNum":"   95","line":"    end"},
{"lineNum":"   96","line":"  end"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"  # :nodoc:"},
{"lineNum":"   99","line":"  protected def self.fork_internal(run_hooks : Bool = true, &block)"},
{"lineNum":"  100","line":"    pid = self.fork_internal(run_hooks)"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"    unless pid"},
{"lineNum":"  103","line":"      begin"},
{"lineNum":"  104","line":"        yield"},
{"lineNum":"  105","line":"        LibC._exit 0"},
{"lineNum":"  106","line":"      rescue ex"},
{"lineNum":"  107","line":"        ex.inspect STDERR"},
{"lineNum":"  108","line":"        STDERR.flush"},
{"lineNum":"  109","line":"        LibC._exit 1"},
{"lineNum":"  110","line":"      ensure"},
{"lineNum":"  111","line":"        LibC._exit 254 # not reached"},
{"lineNum":"  112","line":"      end"},
{"lineNum":"  113","line":"    end"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"    pid"},
{"lineNum":"  116","line":"  end"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"  # *run_hooks* should ALWAYS be `true` unless `exec` is used immediately after fork."},
{"lineNum":"  119","line":"  # Channels, `IO` and other will not work reliably if *run_hooks* is `false`."},
{"lineNum":"  120","line":"  protected def self.fork_internal(run_hooks : Bool = true)"},
{"lineNum":"  121","line":"    pid = LibC.fork"},
{"lineNum":"  122","line":"    case pid"},
{"lineNum":"  123","line":"    when 0"},
{"lineNum":"  124","line":"      pid = nil"},
{"lineNum":"  125","line":"      Process.after_fork_child_callbacks.each(&.call) if run_hooks"},
{"lineNum":"  126","line":"    when -1"},
{"lineNum":"  127","line":"      raise Errno.new(\"fork\")"},
{"lineNum":"  128","line":"    end"},
{"lineNum":"  129","line":"    pid"},
{"lineNum":"  130","line":"  end"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"  # How to redirect the standard input, output and error IO of a process."},
{"lineNum":"  133","line":"  enum Redirect"},
{"lineNum":"  134","line":"    # Pipe the IO so the parent process can read (or write) to the process IO"},
{"lineNum":"  135","line":"    # throught `#input`, `#output` or `#error`."},
{"lineNum":"  136","line":"    Pipe"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"    # Discards the IO."},
{"lineNum":"  139","line":"    Close"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"    # Use the IO of the parent process."},
{"lineNum":"  142","line":"    Inherit"},
{"lineNum":"  143","line":"  end"},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"  # The standard `IO` configuration of a process."},
{"lineNum":"  146","line":"  alias Stdio = Redirect | IO"},
{"lineNum":"  147","line":"  alias Env = Nil | Hash(String, Nil) | Hash(String, String?) | Hash(String, String)"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"  # Executes a process and waits for it to complete."},
{"lineNum":"  150","line":"  #"},
{"lineNum":"  151","line":"  # By default the process is configured without input, output or error."},
{"lineNum":"  152","line":"  def self.run(command : String, args = nil, env : Env = nil, clear_env : Bool = false, shell : Bool = false,"},
{"lineNum":"  153","line":"               input : Stdio = Redirect::Close, output : Stdio = Redirect::Close, error : Stdio = Redirect::Close, chdir : String? = nil) : Process::Status"},
{"lineNum":"  154","line":"    status = new(command, args, env, clear_env, shell, input, output, error, chdir).wait"},
{"lineNum":"  155","line":"    $? = status"},
{"lineNum":"  156","line":"    status"},
{"lineNum":"  157","line":"  end"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"  # Executes a process, yields the block, and then waits for it to finish."},
{"lineNum":"  160","line":"  #"},
{"lineNum":"  161","line":"  # By default the process is configured to use pipes for input, output and error. These"},
{"lineNum":"  162","line":"  # will be closed automatically at the end of the block."},
{"lineNum":"  163","line":"  #"},
{"lineNum":"  164","line":"  # Returns the block\'s value."},
{"lineNum":"  165","line":"  def self.run(command : String, args = nil, env : Env = nil, clear_env : Bool = false, shell : Bool = false,"},
{"lineNum":"  166","line":"               input : Stdio = Redirect::Pipe, output : Stdio = Redirect::Pipe, error : Stdio = Redirect::Pipe, chdir : String? = nil)"},
{"lineNum":"  167","line":"    process = new(command, args, env, clear_env, shell, input, output, error, chdir)"},
{"lineNum":"  168","line":"    begin"},
{"lineNum":"  169","line":"      value = yield process"},
{"lineNum":"  170","line":"      $? = process.wait"},
{"lineNum":"  171","line":"      value"},
{"lineNum":"  172","line":"    rescue ex"},
{"lineNum":"  173","line":"      process.kill"},
{"lineNum":"  174","line":"      raise ex"},
{"lineNum":"  175","line":"    end"},
{"lineNum":"  176","line":"  end"},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"  # Replaces the current process with a new one."},
{"lineNum":"  179","line":"  #"},
{"lineNum":"  180","line":"  # The possible values for *input*, *output* and *error* are:"},
{"lineNum":"  181","line":"  # * `false`: no `IO` (`/dev/null`)"},
{"lineNum":"  182","line":"  # * `true`: inherit from parent"},
{"lineNum":"  183","line":"  # * `IO`: use the given `IO`"},
{"lineNum":"  184","line":"  def self.exec(command : String, args = nil, env : Env = nil, clear_env : Bool = false, shell : Bool = false,"},
{"lineNum":"  185","line":"                input : Stdio = Redirect::Inherit, output : Stdio = Redirect::Inherit, error : Stdio = Redirect::Inherit, chdir : String? = nil)"},
{"lineNum":"  186","line":"    command, argv = prepare_argv(command, args, shell)"},
{"lineNum":"  187","line":"    exec_internal(command, argv, env, clear_env, input, output, error, chdir)"},
{"lineNum":"  188","line":"  end"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"  getter pid : Int32"},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":"  # A pipe to this process\'s input. Raises if a pipe wasn\'t asked when creating the process."},
{"lineNum":"  193","line":"  getter! input : IO::FileDescriptor"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"  # A pipe to this process\'s output. Raises if a pipe wasn\'t asked when creating the process."},
{"lineNum":"  196","line":"  getter! output : IO::FileDescriptor"},
{"lineNum":"  197","line":""},
{"lineNum":"  198","line":"  # A pipe to this process\'s error. Raises if a pipe wasn\'t asked when creating the process."},
{"lineNum":"  199","line":"  getter! error : IO::FileDescriptor"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"  @waitpid_future : Concurrent::Future(Process::Status)"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"  # Creates a process, executes it, but doesn\'t wait for it to complete."},
{"lineNum":"  204","line":"  #"},
{"lineNum":"  205","line":"  # To wait for it to finish, invoke `wait`."},
{"lineNum":"  206","line":"  #"},
{"lineNum":"  207","line":"  # By default the process is configured without input, output or error."},
{"lineNum":"  208","line":"  def initialize(command : String, args = nil, env : Env = nil, clear_env : Bool = false, shell : Bool = false,"},
{"lineNum":"  209","line":"                 input : Stdio = Redirect::Close, output : Stdio = Redirect::Close, error : Stdio = Redirect::Close, chdir : String? = nil)"},
{"lineNum":"  210","line":"    command, argv = Process.prepare_argv(command, args, shell)"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"    @wait_count = 0"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"    if needs_pipe?(input)"},
{"lineNum":"  215","line":"      fork_input, process_input = IO.pipe(read_blocking: true)"},
{"lineNum":"  216","line":"      if input.is_a?(IO)"},
{"lineNum":"  217","line":"        @wait_count += 1"},
{"lineNum":"  218","line":"        spawn { copy_io(input, process_input, channel, close_dst: true) }"},
{"lineNum":"  219","line":"      else"},
{"lineNum":"  220","line":"        @input = process_input"},
{"lineNum":"  221","line":"      end"},
{"lineNum":"  222","line":"    end"},
{"lineNum":"  223","line":""},
{"lineNum":"  224","line":"    if needs_pipe?(output)"},
{"lineNum":"  225","line":"      process_output, fork_output = IO.pipe(write_blocking: true)"},
{"lineNum":"  226","line":"      if output.is_a?(IO)"},
{"lineNum":"  227","line":"        @wait_count += 1"},
{"lineNum":"  228","line":"        spawn { copy_io(process_output, output, channel, close_src: true) }"},
{"lineNum":"  229","line":"      else"},
{"lineNum":"  230","line":"        @output = process_output"},
{"lineNum":"  231","line":"      end"},
{"lineNum":"  232","line":"    end"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"    if needs_pipe?(error)"},
{"lineNum":"  235","line":"      process_error, fork_error = IO.pipe(write_blocking: true)"},
{"lineNum":"  236","line":"      if error.is_a?(IO)"},
{"lineNum":"  237","line":"        @wait_count += 1"},
{"lineNum":"  238","line":"        spawn { copy_io(process_error, error, channel, close_src: true) }"},
{"lineNum":"  239","line":"      else"},
{"lineNum":"  240","line":"        @error = process_error"},
{"lineNum":"  241","line":"      end"},
{"lineNum":"  242","line":"    end"},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"    @pid = Process.fork_internal(run_hooks: false) do"},
{"lineNum":"  245","line":"      begin"},
{"lineNum":"  246","line":"        Process.exec_internal("},
{"lineNum":"  247","line":"          command,"},
{"lineNum":"  248","line":"          argv,"},
{"lineNum":"  249","line":"          env,"},
{"lineNum":"  250","line":"          clear_env,"},
{"lineNum":"  251","line":"          fork_input || input,"},
{"lineNum":"  252","line":"          fork_output || output,"},
{"lineNum":"  253","line":"          fork_error || error,"},
{"lineNum":"  254","line":"          chdir"},
{"lineNum":"  255","line":"        )"},
{"lineNum":"  256","line":"      rescue ex"},
{"lineNum":"  257","line":"        ex.inspect_with_backtrace STDERR"},
{"lineNum":"  258","line":"      ensure"},
{"lineNum":"  259","line":"        LibC._exit 127"},
{"lineNum":"  260","line":"      end"},
{"lineNum":"  261","line":"    end"},
{"lineNum":"  262","line":""},
{"lineNum":"  263","line":"    @waitpid_future = Event::SignalChildHandler.instance.waitpid(pid)"},
{"lineNum":"  264","line":""},
{"lineNum":"  265","line":"    fork_input.try &.close"},
{"lineNum":"  266","line":"    fork_output.try &.close"},
{"lineNum":"  267","line":"    fork_error.try &.close"},
{"lineNum":"  268","line":"  end"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"  private def initialize(@pid)"},
{"lineNum":"  271","line":"    @waitpid_future = Event::SignalChildHandler.instance.waitpid(pid)"},
{"lineNum":"  272","line":"    @wait_count = 0"},
{"lineNum":"  273","line":"  end"},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"  # See also: `Process.kill`"},
{"lineNum":"  276","line":"  def kill(sig = Signal::TERM)"},
{"lineNum":"  277","line":"    Process.kill sig, @pid"},
{"lineNum":"  278","line":"  end"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"  # Waits for this process to complete and closes any pipes."},
{"lineNum":"  281","line":"  def wait : Process::Status"},
{"lineNum":"  282","line":"    close_io @input # only closed when a pipe was created but not managed by copy_io"},
{"lineNum":"  283","line":""},
{"lineNum":"  284","line":"    @wait_count.times do"},
{"lineNum":"  285","line":"      ex = channel.receive"},
{"lineNum":"  286","line":"      raise ex if ex"},
{"lineNum":"  287","line":"    end"},
{"lineNum":"  288","line":"    @wait_count = 0"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"    @waitpid_future.get"},
{"lineNum":"  291","line":"  ensure"},
{"lineNum":"  292","line":"    close"},
{"lineNum":"  293","line":"  end"},
{"lineNum":"  294","line":""},
{"lineNum":"  295","line":"  # Whether the process is still registered in the system."},
{"lineNum":"  296","line":"  # Note that this returns `true` for processes in the zombie or similar state."},
{"lineNum":"  297","line":"  def exists?"},
{"lineNum":"  298","line":"    !terminated?"},
{"lineNum":"  299","line":"  end"},
{"lineNum":"  300","line":""},
{"lineNum":"  301","line":"  # Whether this process is already terminated."},
{"lineNum":"  302","line":"  def terminated?"},
{"lineNum":"  303","line":"    @waitpid_future.completed? || !Process.exists?(@pid)"},
{"lineNum":"  304","line":"  end"},
{"lineNum":"  305","line":""},
{"lineNum":"  306","line":"  # Closes any pipes to the child process."},
{"lineNum":"  307","line":"  def close"},
{"lineNum":"  308","line":"    close_io @input"},
{"lineNum":"  309","line":"    close_io @output"},
{"lineNum":"  310","line":"    close_io @error"},
{"lineNum":"  311","line":"  end"},
{"lineNum":"  312","line":""},
{"lineNum":"  313","line":"  # :nodoc:"},
{"lineNum":"  314","line":"  protected def self.prepare_argv(command, args, shell)"},
{"lineNum":"  315","line":"    if shell"},
{"lineNum":"  316","line":"      command = %(#{command} \"${@}\") unless command.includes?(\' \')"},
{"lineNum":"  317","line":"      shell_args = [\"-c\", command, \"--\"]"},
{"lineNum":"  318","line":""},
{"lineNum":"  319","line":"      if args"},
{"lineNum":"  320","line":"        unless command.includes?(%(\"${@}\"))"},
{"lineNum":"  321","line":"          raise ArgumentError.new(%(can\'t specify arguments in both, command and args without including \"${@}\" into your command))"},
{"lineNum":"  322","line":"        end"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"        {% if flag?(:freebsd) %}"},
{"lineNum":"  325","line":"          shell_args << \"\""},
{"lineNum":"  326","line":"        {% end %}"},
{"lineNum":"  327","line":""},
{"lineNum":"  328","line":"        shell_args.concat(args)"},
{"lineNum":"  329","line":"      end"},
{"lineNum":"  330","line":""},
{"lineNum":"  331","line":"      command = \"/bin/sh\""},
{"lineNum":"  332","line":"      args = shell_args"},
{"lineNum":"  333","line":"    end"},
{"lineNum":"  334","line":""},
{"lineNum":"  335","line":"    argv = [command.to_unsafe]"},
{"lineNum":"  336","line":"    args.try &.each do |arg|"},
{"lineNum":"  337","line":"      argv << arg.to_unsafe"},
{"lineNum":"  338","line":"    end"},
{"lineNum":"  339","line":"    argv << Pointer(UInt8).null"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"    {command, argv}"},
{"lineNum":"  342","line":"  end"},
{"lineNum":"  343","line":""},
{"lineNum":"  344","line":"  private def channel"},
{"lineNum":"  345","line":"    @channel ||= Channel(Exception?).new"},
{"lineNum":"  346","line":"  end"},
{"lineNum":"  347","line":""},
{"lineNum":"  348","line":"  private def needs_pipe?(io)"},
{"lineNum":"  349","line":"    (io == Redirect::Pipe) || (io.is_a?(IO) && !io.is_a?(IO::FileDescriptor))"},
{"lineNum":"  350","line":"  end"},
{"lineNum":"  351","line":""},
{"lineNum":"  352","line":"  private def copy_io(src, dst, channel, close_src = false, close_dst = false)"},
{"lineNum":"  353","line":"    return unless src.is_a?(IO) && dst.is_a?(IO)"},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"    begin"},
{"lineNum":"  356","line":"      IO.copy(src, dst)"},
{"lineNum":"  357","line":""},
{"lineNum":"  358","line":"      # close is called here to trigger exceptions"},
{"lineNum":"  359","line":"      # close must be called before channel.send or the process may deadlock"},
{"lineNum":"  360","line":"      src.close if close_src"},
{"lineNum":"  361","line":"      close_src = false"},
{"lineNum":"  362","line":"      dst.close if close_dst"},
{"lineNum":"  363","line":"      close_dst = false"},
{"lineNum":"  364","line":""},
{"lineNum":"  365","line":"      channel.send nil"},
{"lineNum":"  366","line":"    rescue ex"},
{"lineNum":"  367","line":"      channel.send ex"},
{"lineNum":"  368","line":"    ensure"},
{"lineNum":"  369","line":"      # any exceptions are silently ignored because of spawn"},
{"lineNum":"  370","line":"      src.close if close_src"},
{"lineNum":"  371","line":"      dst.close if close_dst"},
{"lineNum":"  372","line":"    end"},
{"lineNum":"  373","line":"  end"},
{"lineNum":"  374","line":""},
{"lineNum":"  375","line":"  # :nodoc:"},
{"lineNum":"  376","line":"  protected def self.exec_internal(command : String, argv, env, clear_env, input, output, error, chdir)"},
{"lineNum":"  377","line":"    reopen_io(input, STDIN, \"r\")"},
{"lineNum":"  378","line":"    reopen_io(output, STDOUT, \"w\")"},
{"lineNum":"  379","line":"    reopen_io(error, STDERR, \"w\")"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"    ENV.clear if clear_env"},
{"lineNum":"  382","line":"    env.try &.each do |key, val|"},
{"lineNum":"  383","line":"      if val"},
{"lineNum":"  384","line":"        ENV[key] = val"},
{"lineNum":"  385","line":"      else"},
{"lineNum":"  386","line":"        ENV.delete key"},
{"lineNum":"  387","line":"      end"},
{"lineNum":"  388","line":"    end"},
{"lineNum":"  389","line":""},
{"lineNum":"  390","line":"    Dir.cd(chdir) if chdir"},
{"lineNum":"  391","line":""},
{"lineNum":"  392","line":"    if LibC.execvp(command, argv) == -1"},
{"lineNum":"  393","line":"      raise Errno.new(\"execvp\")"},
{"lineNum":"  394","line":"    end"},
{"lineNum":"  395","line":"  end"},
{"lineNum":"  396","line":""},
{"lineNum":"  397","line":"  private def self.reopen_io(src_io, dst_io, mode)"},
{"lineNum":"  398","line":"    case src_io"},
{"lineNum":"  399","line":"    when IO::FileDescriptor"},
{"lineNum":"  400","line":"      src_io.blocking = true"},
{"lineNum":"  401","line":"      dst_io.reopen(src_io)"},
{"lineNum":"  402","line":"    when Redirect::Inherit"},
{"lineNum":"  403","line":"      dst_io.blocking = true"},
{"lineNum":"  404","line":"    when Redirect::Close"},
{"lineNum":"  405","line":"      File.open(\"/dev/null\", mode) do |file|"},
{"lineNum":"  406","line":"        dst_io.reopen(file)"},
{"lineNum":"  407","line":"      end"},
{"lineNum":"  408","line":"    else"},
{"lineNum":"  409","line":"      raise \"BUG: unknown object type #{src_io}\""},
{"lineNum":"  410","line":"    end"},
{"lineNum":"  411","line":""},
{"lineNum":"  412","line":"    dst_io.close_on_exec = false"},
{"lineNum":"  413","line":"  end"},
{"lineNum":"  414","line":""},
{"lineNum":"  415","line":"  private def close_io(io)"},
{"lineNum":"  416","line":"    io.close if io"},
{"lineNum":"  417","line":"  end"},
{"lineNum":"  418","line":"end"},
{"lineNum":"  419","line":""},
{"lineNum":"  420","line":"# Executes the given command in a subshell."},
{"lineNum":"  421","line":"# Standard input, output and error are inherited."},
{"lineNum":"  422","line":"# Returns `true` if the command gives zero exit code, `false` otherwise."},
{"lineNum":"  423","line":"# The special `$?` variable is set to a `Process::Status` associated with this execution."},
{"lineNum":"  424","line":"#"},
{"lineNum":"  425","line":"# If *command* contains no spaces and *args* is given, it will become"},
{"lineNum":"  426","line":"# its argument list."},
{"lineNum":"  427","line":"#"},
{"lineNum":"  428","line":"# If *command* contains spaces and *args* is given, *command* must include"},
{"lineNum":"  429","line":"# `\"${@}\"` (including the quotes) to receive the argument list."},
{"lineNum":"  430","line":"#"},
{"lineNum":"  431","line":"# No shell interpretation is done in *args*."},
{"lineNum":"  432","line":"#"},
{"lineNum":"  433","line":"# Example:"},
{"lineNum":"  434","line":"#"},
{"lineNum":"  435","line":"# ```"},
{"lineNum":"  436","line":"# system(\"echo *\")"},
{"lineNum":"  437","line":"# ```"},
{"lineNum":"  438","line":"#"},
{"lineNum":"  439","line":"# Produces:"},
{"lineNum":"  440","line":"#"},
{"lineNum":"  441","line":"# ```text"},
{"lineNum":"  442","line":"# LICENSE shard.yml Readme.md spec src"},
{"lineNum":"  443","line":"# ```"},
{"lineNum":"  444","line":"def system(command : String, args = nil) : Bool"},
{"lineNum":"  445","line":"  status = Process.run(command, args, shell: true, input: Process::Redirect::Inherit, output: Process::Redirect::Inherit, error: Process::Redirect::Inherit)"},
{"lineNum":"  446","line":"  $? = status"},
{"lineNum":"  447","line":"  status.success?"},
{"lineNum":"  448","line":"end"},
{"lineNum":"  449","line":""},
{"lineNum":"  450","line":"# Returns the standard output of executing *command* in a subshell."},
{"lineNum":"  451","line":"# Standard input, and error are inherited."},
{"lineNum":"  452","line":"# The special `$?` variable is set to a `Process::Status` associated with this execution."},
{"lineNum":"  453","line":"#"},
{"lineNum":"  454","line":"# Example:"},
{"lineNum":"  455","line":"#"},
{"lineNum":"  456","line":"# ```"},
{"lineNum":"  457","line":"# `echo hi` # => \"hi\\n\""},
{"lineNum":"  458","line":"# ```"},
{"lineNum":"  459","line":"def `(command) : String"},
{"lineNum":"  460","line":"  process = Process.new(command, shell: true, input: Process::Redirect::Inherit, output: Process::Redirect::Pipe, error: Process::Redirect::Inherit)"},
{"lineNum":"  461","line":"  output = process.output.gets_to_end"},
{"lineNum":"  462","line":"  status = process.wait"},
{"lineNum":"  463","line":"  $? = status"},
{"lineNum":"  464","line":"  output"},
{"lineNum":"  465","line":"end"},
{"lineNum":"  466","line":""},
{"lineNum":"  467","line":"# See also: `Process.fork`"},
{"lineNum":"  468","line":"def fork"},
{"lineNum":"  469","line":"  Process.fork { yield }"},
{"lineNum":"  470","line":"end"},
{"lineNum":"  471","line":""},
{"lineNum":"  472","line":"# See also: `Process.fork`"},
{"lineNum":"  473","line":"def fork"},
{"lineNum":"  474","line":"  Process.fork"},
{"lineNum":"  475","line":"end"},
{"lineNum":"  476","line":""},
{"lineNum":"  477","line":"require \"./process/*\""},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "roman_spec", "date" : "2018-03-12 14:57:27", "instrumented" : 1, "covered" : 0,};
var merged_data = [];
