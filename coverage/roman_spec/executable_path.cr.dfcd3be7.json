var data = {lines:[
{"lineNum":"    1","line":"# Reference:","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"    2","line":"# - https://github.com/gpakosz/whereami/blob/master/src/whereami.c"},
{"lineNum":"    3","line":"# - http://stackoverflow.com/questions/1023306/finding-current-executables-path-without-proc-self-exe"},
{"lineNum":"    4","line":""},
{"lineNum":"    5","line":"class Process"},
{"lineNum":"    6","line":"  PATH_DELIMITER = {% if flag?(:windows) %} \';\' {% else %} \':\' {% end %}"},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"  # :nodoc:"},
{"lineNum":"    9","line":"  INITIAL_PATH = ENV[\"PATH\"]?"},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"  # :nodoc:"},
{"lineNum":"   12","line":"  INITIAL_PWD = Dir.current"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"  # Returns an absolute path to the executable file of the currently running"},
{"lineNum":"   15","line":"  # program. This is in opposition to `PROGRAM_NAME` which may be a relative or"},
{"lineNum":"   16","line":"  # absolute path, just the executable file name or a symlink."},
{"lineNum":"   17","line":"  #"},
{"lineNum":"   18","line":"  # The executable path will be canonicalized (all symlinks and relative paths"},
{"lineNum":"   19","line":"  # will be expanded)."},
{"lineNum":"   20","line":"  #"},
{"lineNum":"   21","line":"  # Returns `nil` if the file can\'t be found."},
{"lineNum":"   22","line":"  def self.executable_path"},
{"lineNum":"   23","line":"    if executable = executable_path_impl"},
{"lineNum":"   24","line":"      begin"},
{"lineNum":"   25","line":"        File.real_path(executable)"},
{"lineNum":"   26","line":"      rescue Errno"},
{"lineNum":"   27","line":"      end"},
{"lineNum":"   28","line":"    end"},
{"lineNum":"   29","line":"  end"},
{"lineNum":"   30","line":""},
{"lineNum":"   31","line":"  # Searches an executable, checking for an absolute path, a path relative to"},
{"lineNum":"   32","line":"  # *pwd* or absolute path, then eventually searching in directories declared"},
{"lineNum":"   33","line":"  # in *path*."},
{"lineNum":"   34","line":"  def self.find_executable(name, path = ENV[\"PATH\"]?, pwd = Dir.current)"},
{"lineNum":"   35","line":"    if name.starts_with?(File::SEPARATOR)"},
{"lineNum":"   36","line":"      return name"},
{"lineNum":"   37","line":"    end"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"    if name.includes?(File::SEPARATOR)"},
{"lineNum":"   40","line":"      return File.expand_path(name, pwd)"},
{"lineNum":"   41","line":"    end"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"    return unless path"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"    path.split(PATH_DELIMITER).each do |path|"},
{"lineNum":"   46","line":"      executable = File.join(path, name)"},
{"lineNum":"   47","line":"      return executable if File.exists?(executable)"},
{"lineNum":"   48","line":"    end"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"    nil"},
{"lineNum":"   51","line":"  end"},
{"lineNum":"   52","line":"end"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"{% if flag?(:darwin) %}"},
{"lineNum":"   55","line":"  lib LibC"},
{"lineNum":"   56","line":"    PATH_MAX = 1024"},
{"lineNum":"   57","line":"    fun _NSGetExecutablePath(buf : Char*, bufsize : UInt32*) : Int"},
{"lineNum":"   58","line":"  end"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"  class Process"},
{"lineNum":"   61","line":"    private def self.executable_path_impl"},
{"lineNum":"   62","line":"      buf = GC.malloc_atomic(LibC::PATH_MAX).as(UInt8*)"},
{"lineNum":"   63","line":"      size = LibC::PATH_MAX.to_u32"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"      if LibC._NSGetExecutablePath(buf, pointerof(size)) == -1"},
{"lineNum":"   66","line":"        buf = GC.malloc_atomic(size).as(UInt8*)"},
{"lineNum":"   67","line":"        return nil if LibC._NSGetExecutablePath(buf, pointerof(size)) == -1"},
{"lineNum":"   68","line":"      end"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"      String.new(buf)"},
{"lineNum":"   71","line":"    end"},
{"lineNum":"   72","line":"  end"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"{% elsif flag?(:freebsd) %}"},
{"lineNum":"   75","line":"  require \"c/sysctl\""},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"  class Process"},
{"lineNum":"   78","line":"    private def self.executable_path_impl"},
{"lineNum":"   79","line":"      mib = Int32[LibC::CTL_KERN, LibC::KERN_PROC, LibC::KERN_PROC_PATHNAME, -1]"},
{"lineNum":"   80","line":"      buf = GC.malloc_atomic(LibC::PATH_MAX).as(UInt8*)"},
{"lineNum":"   81","line":"      size = LibC::SizeT.new(LibC::PATH_MAX)"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"      if LibC.sysctl(mib, 4, buf, pointerof(size), nil, 0) == 0"},
{"lineNum":"   84","line":"        String.new(buf, size - 1)"},
{"lineNum":"   85","line":"      end"},
{"lineNum":"   86","line":"    end"},
{"lineNum":"   87","line":"  end"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"{% elsif flag?(:linux) %}"},
{"lineNum":"   90","line":"  class Process"},
{"lineNum":"   91","line":"    private def self.executable_path_impl"},
{"lineNum":"   92","line":"      \"/proc/self/exe\""},
{"lineNum":"   93","line":"    end"},
{"lineNum":"   94","line":"  end"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"{% else %} # openbsd, ..."},
{"lineNum":"   97","line":"  class Process"},
{"lineNum":"   98","line":"    private def self.executable_path_impl"},
{"lineNum":"   99","line":"      find_executable(PROGRAM_NAME, INITIAL_PATH, INITIAL_PWD)"},
{"lineNum":"  100","line":"    end"},
{"lineNum":"  101","line":"  end"},
{"lineNum":"  102","line":"{% end %}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "roman_spec", "date" : "2018-03-12 14:57:27", "instrumented" : 1, "covered" : 0,};
var merged_data = [];
